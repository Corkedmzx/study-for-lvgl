/**
 * @file touch_draw.c.git
 * @brief 触摸绘图功能模块实现（Git版本，不含敏感信息）
 * 
 * 基于05touch.cpp的功能，集成到LVGL系统中
 * 支持触摸屏绘图，使用framebuffer直接绘制
 * 
 * 注意：此文件是用于Git提交的清理版本，不包含敏感信息
 * 实际使用的文件是 touch_draw.c（已添加到.gitignore）
 */

#include "touch_draw.h"
#include "../common/common.h"
#include "../common/touch_device.h"
#include "../collaborative_draw/collaborative_draw.h"
#include "lvgl/src/font/lv_font.h"
#include "lvgl/src/font/lv_symbol_def.h"

// 协作绘图配置
// 如果配置文件存在，直接包含；如果不存在，使用下面的默认占位符
// 注意：配置文件 collaborative_draw_config.h 需要从模板文件创建
// 详见 CONFIGURATION.md 和 src/collaborative_draw/collaborative_draw_config.h.example
#ifndef COLLAB_DEVICE_NAME
    #define COLLAB_DEVICE_NAME "your_device_name"
#endif
#ifndef COLLAB_PRIVATE_KEY
    #define COLLAB_PRIVATE_KEY "your_private_key_here"
#endif
// 取消注释下面这行以使用配置文件（创建配置文件后）
// 注意：Git版本中此包含行已注释，实际使用时需要取消注释并创建配置文件
// #include "../collaborative_draw/collaborative_draw_config.h"

#include <stdio.h>
 #include <stdlib.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <linux/input.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <linux/fb.h>
 #include <string.h>
 #include <errno.h>
 #include <stdint.h>
 #include <pthread.h>
 #include <signal.h>
 #include <stdint.h>
 #include <inttypes.h>
 #include <time.h>
 
 // 设备路径
 #define TOUCH_DEVICE "/dev/input/event0"
 #define FRAMEBUFFER_DEV "/dev/fb0"
 
 // 屏幕分辨率
 #define SCREEN_WIDTH 800
 #define SCREEN_HEIGHT 480
 
 // Linux framebuffer通常使用BGRA格式（而不是ARGB）
 // 需要将ARGB格式转换为BGRA格式
 // ARGB格式：0xAARRGGBB (Alpha, Red, Green, Blue)
 // BGRA格式：0xBBGGRRAA (Blue, Green, Red, Alpha)
 
 // ARGB格式的颜色定义（alpha通道应该是0xFF表示不透明）
 // 注意：ARGB格式是 0xAARRGGBB（高位到低位：Alpha, Red, Green, Blue）
 #define COLOR_RED_ARGB     0xFFFF0000  // A=0xFF, R=0xFF, G=0x00, B=0x00 (红色)
 #define COLOR_GREEN_ARGB   0xFF00FF00  // A=0xFF, R=0x00, G=0xFF, B=0x00 (绿色)
 #define COLOR_BLUE_ARGB    0xFF0000FF  // A=0xFF, R=0x00, G=0x00, B=0xFF (蓝色)
 #define COLOR_YELLOW_ARGB  0xFFFFFF00  // A=0xFF, R=0xFF, G=0xFF, B=0x00 (黄色)
 #define COLOR_GRAY_ARGB    0xFF808080  // A=0xFF, R=0x80, G=0x80, B=0x80 (灰色)
 #define COLOR_WHITE_ARGB   0xFFFFFFFF  // A=0xFF, R=0xFF, G=0xFF, B=0xFF (白色)
 #define COLOR_BLACK_ARGB   0xFF000000  // A=0xFF, R=0x00, G=0x00, B=0x00 (黑色)
 
 // ARGB转BGRA的函数
 // LVGL使用BGRA格式：blue在最低字节，alpha在最高字节
 // ARGB格式：0xAARRGGBB (高字节到低字节: Alpha, Red, Green, Blue)
 // BGRA格式：0xAARRGGBB (但结构体是: blue, green, red, alpha)
 // 在小端序中，BGRA结构体存储为：低地址[b][g][r][a]高地址
 // 所以uint32_t值应该是：0xAARRGGBB，其中：
 //   字节0(低位): B (blue)
 //   字节1: G (green)  
 //   字节2: R (red)
 //   字节3(高位): A (alpha)
 static inline uint32_t argb_to_bgra(uint32_t argb) {
     uint32_t a = (argb >> 24) & 0xFF;  // Alpha
     uint32_t r = (argb >> 16) & 0xFF;  // Red
     uint32_t g = (argb >> 8) & 0xFF;   // Green
     uint32_t b = (argb >> 0) & 0xFF;   // Blue
     // 转换为BGRA格式的uint32_t: 低字节到高字节是[b][g][r][a]
     // 在小端序中，0xAARRGGBB表示字节顺序从低到高是[b][g][r][a]
     return (b) | (g << 8) | (r << 16) | (a << 24);
 }
 
 // 转换为framebuffer期望的颜色格式
 // 根据错误报告：红色绘制成蓝色，说明R和B的位置交换了
 // framebuffer可能期望ARGB格式（0xAARRGGBB）而不是BGRA
 // 或者framebuffer期望RGBA格式，或者需要字节交换
 // 测试：如果红色(R=255,G=0,B=0)绘制成蓝色，可能是：
 // - 当前写的是BGRA格式的红色：0xFF0000FF (B=0, G=0, R=255, A=255)
 // - framebuffer期望ARGB格式：0xFFFF0000 (A=255, R=255, G=0, B=0)
 // 如果framebuffer按ARGB解释，0xFF0000FF会被解释为蓝色(B=255)
 // 因此需要转换为ARGB格式
 // ARGB格式：0xAARRGGBB (Alpha, Red, Green, Blue)
 #define COLOR_RED_BGRA     0xFFFF0000  // ARGB: 红色 R=255, G=0, B=0
 #define COLOR_GREEN_BGRA   0xFF00FF00  // ARGB: 绿色 R=0, G=255, B=0
 #define COLOR_BLUE_BGRA    0xFF0000FF  // ARGB: 蓝色 R=0, G=0, B=255
 #define COLOR_YELLOW_BGRA  0xFFFFFF00  // ARGB: 黄色 R=255, G=255, B=0
 #define COLOR_GRAY_BGRA    0xFF808080  // ARGB: 灰色 R=128, G=128, B=128
 #define COLOR_WHITE_BGRA   0xFFFFFFFF  // ARGB: 白色 R=255, G=255, B=255
 #define COLOR_BLACK_BGRA   0xFF000000  // ARGB: 黑色 R=0, G=0, B=0
 
 // 兼容宏（使用BGRA值）
 #define COLOR_RED     COLOR_RED_BGRA
 #define COLOR_GREEN   COLOR_GREEN_BGRA
 #define COLOR_BLUE    COLOR_BLUE_BGRA
 #define COLOR_YELLOW  COLOR_YELLOW_BGRA
 #define COLOR_GRAY    COLOR_GRAY_BGRA
 #define COLOR_WHITE   COLOR_WHITE_BGRA
 #define COLOR_BLACK   COLOR_BLACK_BGRA
 
 // 触摸状态
 enum TouchState {
     TOUCH_IDLE,
     TOUCH_PRESSED,
     TOUCH_MOVING
 };
 
 struct FramebufferInfo {
     int fd;
     char* fbp;
     struct fb_var_screeninfo vinfo;
     struct fb_fix_screeninfo finfo;
     long int screensize;
 };
 
// 全局变量
static lv_obj_t *touch_draw_window = NULL;
static bool touch_draw_running = false;
 static pthread_t touch_draw_thread;
 static struct FramebufferInfo fb_info;
 static int touch_fd = -1;
 static int saved_page_index = 0;  // 保存进入触摸绘图时的页面索引
 static pthread_mutex_t fb_mutex = PTHREAD_MUTEX_INITIALIZER;  // 保护framebuffer访问的互斥锁

// 触摸坐标范围
static int touch_min_x = 0;
static int touch_max_x = 1024;
static int touch_min_y = 0;
static int touch_max_y = 600;

// 绘图状态变量
static int pen_size = 2;  // 笔触大小：1=细，2=中，3=粗
static int current_color_index = 0;  // 当前颜色索引
static bool eraser_mode = false;  // 橡皮擦模式
static bool collaborative_mode = true;  // 协作绘图模式（默认启用）
static uint32_t color_list[] = {
    COLOR_RED_BGRA,
    COLOR_GREEN_BGRA,
    COLOR_BLUE_BGRA,
    COLOR_YELLOW_BGRA,
    COLOR_BLACK_BGRA,
    COLOR_GRAY_BGRA,
};
static const int color_count = sizeof(color_list) / sizeof(color_list[0]);

// 虚拟机(SDL)模式下：使用framebuffer方式绘制（与开发板相同）
#if USE_SDL
#include <SDL2/SDL.h>

// SDL模式下的虚拟framebuffer（800x480，32位BGRA，与开发板framebuffer格式相同）
#define SDL_FB_WIDTH 800
#define SDL_FB_HEIGHT 480
static uint32_t *sdl_framebuffer = NULL;  // 虚拟framebuffer内存
static pthread_mutex_t sdl_fb_mutex = PTHREAD_MUTEX_INITIALIZER;
static struct FramebufferInfo sdl_fb_info;  // 虚拟framebuffer信息
static SDL_Window *sdl_overlay_window = NULL;  // SDL覆盖窗口（用于显示绘图）
static SDL_Renderer *sdl_overlay_renderer = NULL;  // SDL渲染器
static SDL_Texture *sdl_overlay_texture = NULL;  // SDL纹理
static lv_timer_t *sdl_refresh_timer = NULL;  // 定时器：刷新SDL窗口
static pthread_t sdl_mouse_thread = 0;  // SDL鼠标输入处理线程
static bool sdl_mouse_thread_running = false;  // SDL鼠标线程运行标志

// SDL鼠标输入处理线程函数（用于虚拟机双向绘制）
static void* sdl_mouse_thread_func(void* arg) {
    (void)arg;
    
    printf("[SDL鼠标] 线程启动\n");
    
    // 鼠标状态
    bool mouse_pressed = false;
    int last_screen_x = 0, last_screen_y = 0;
    bool is_first_point = true;
    
    // 使用SDL_GetMouseState获取鼠标状态（不干扰LVGL的事件处理）
    bool last_mouse_state = false;
    
    // 主事件循环
    while (sdl_mouse_thread_running) {
        // 检查framebuffer是否已初始化
        if (!sdl_framebuffer) {
            usleep(10000);  // 10ms
            continue;
        }
        
        // 使用SDL_GetMouseState获取鼠标状态（不干扰LVGL的事件处理）
        int mouse_x, mouse_y;
        Uint32 mouse_buttons = SDL_GetMouseState(&mouse_x, &mouse_y);
        bool current_mouse_state = (mouse_buttons & SDL_BUTTON(SDL_BUTTON_LEFT)) != 0;
        
        // 检查鼠标状态变化
        if (current_mouse_state && !last_mouse_state) {
            // 鼠标按下
            // 检查是否在绘图区域（排除工具栏）
            bool in_toolbar = false;
            if (mouse_y < 60 || mouse_y >= 400 || mouse_x >= 720) {
                in_toolbar = true;
            }
            
            if (!in_toolbar && mouse_x >= 0 && mouse_x < SDL_FB_WIDTH && mouse_y >= 0 && mouse_y < SDL_FB_HEIGHT) {
                mouse_pressed = true;
                last_screen_x = mouse_x;
                last_screen_y = mouse_y;
                is_first_point = true;
                printf("[SDL鼠标] 鼠标按下: (%d, %d)\n", mouse_x, mouse_y);
            }
        } else if (!current_mouse_state && last_mouse_state) {
            // 鼠标释放
            if (mouse_pressed) {
                mouse_pressed = false;
                is_first_point = true;
                printf("[SDL鼠标] 鼠标释放\n");
            }
        } else if (current_mouse_state && mouse_pressed) {
            // 鼠标移动（按下状态）
            // 检查是否在绘图区域
            bool in_toolbar = false;
            if (mouse_y < 60 || mouse_y >= 400 || mouse_x >= 720) {
                in_toolbar = true;
            }
            
            if (!in_toolbar && mouse_x >= 0 && mouse_x < SDL_FB_WIDTH && mouse_y >= 0 && mouse_y < SDL_FB_HEIGHT) {
                int screen_x = mouse_x;
                int screen_y = mouse_y;
                
                // 获取当前绘制参数
                uint32_t draw_color = eraser_mode ? COLOR_WHITE : color_list[current_color_index];
                int radius = pen_size;
                
                // 如果是第一个点，直接绘制点
                if (is_first_point) {
                    is_first_point = false;
                    last_screen_x = screen_x;
                    last_screen_y = screen_y;
                }
                
                // 绘制线条
                pthread_mutex_lock(&sdl_fb_mutex);
                
                // 计算步数
                int dx = abs(screen_x - last_screen_x);
                int dy = abs(screen_y - last_screen_y);
                int steps = (dx > dy ? dx : dy) + 1;
                if (steps > 1000) steps = 1000;
                
                // 绘制线条上的每个点
                for (int i = 0; i <= steps; i++) {
                    int px = last_screen_x + (int)((screen_x - last_screen_x) * i / steps);
                    int py = last_screen_y + (int)((screen_y - last_screen_y) * i / steps);
                    
                    // 检查坐标有效性
                    if (px >= 0 && px < SDL_FB_WIDTH && py >= 0 && py < SDL_FB_HEIGHT) {
                        // 根据半径绘制圆形区域
                        for (int ddy = -radius; ddy <= radius; ddy++) {
                            for (int ddx = -radius; ddx <= radius; ddx++) {
                                // 检查是否在圆形内
                                if (ddx * ddx + ddy * ddy <= radius * radius) {
                                    int fx = px + ddx;
                                    int fy = py + ddy;
                                    // 检查边界
                                    if (fx >= 0 && fx < SDL_FB_WIDTH && fy >= 0 && fy < SDL_FB_HEIGHT) {
                                        sdl_framebuffer[fy * SDL_FB_WIDTH + fx] = draw_color;
                                    }
                                }
                            }
                        }
                    }
                }
                
                pthread_mutex_unlock(&sdl_fb_mutex);
                
                // 如果启用协作模式，发送绘图操作到服务器
                if (collaborative_mode && collaborative_draw_get_state() == COLLAB_DRAW_STATE_CONNECTED) {
                    // 将屏幕坐标转换为触摸坐标（用于发送到服务器）
                    // 触摸坐标范围：X[0-1024], Y[0-600]
                    // 屏幕坐标范围：X[0-800], Y[0-480]
                    int touch_x = (screen_x * 1024) / SDL_FB_WIDTH;
                    int touch_y = (screen_y * 600) / SDL_FB_HEIGHT;
                    int touch_prev_x = (last_screen_x * 1024) / SDL_FB_WIDTH;
                    int touch_prev_y = (last_screen_y * 600) / SDL_FB_HEIGHT;
                    
                    collaborative_draw_send_operation(
                        touch_x, touch_y,
                        touch_prev_x, touch_prev_y,
                        pen_size, draw_color, eraser_mode);
                }
                
                // 更新上一个点的坐标
                last_screen_x = screen_x;
                last_screen_y = screen_y;
            }
        }
        
        last_mouse_state = current_mouse_state;
        
        // 避免CPU占用过高
        usleep(10000);  // 10ms
    }
    
    printf("[SDL鼠标] 线程退出\n");
    return NULL;
}

// 初始化SDL虚拟framebuffer
static void sdl_fb_init(void) {
    if (sdl_framebuffer) return;  // 已初始化
    
    printf("[SDL Framebuffer] 开始初始化...\n");
    
    // 分配内存
    sdl_framebuffer = (uint32_t*)malloc(SDL_FB_WIDTH * SDL_FB_HEIGHT * sizeof(uint32_t));
    if (!sdl_framebuffer) {
        printf("[SDL Framebuffer] 内存分配失败\n");
        return;
    }
    
    // 初始化framebuffer信息结构
    memset(&sdl_fb_info, 0, sizeof(sdl_fb_info));
    sdl_fb_info.fbp = (char*)sdl_framebuffer;
    sdl_fb_info.vinfo.xres = SDL_FB_WIDTH;
    sdl_fb_info.vinfo.yres = SDL_FB_HEIGHT;
    sdl_fb_info.finfo.line_length = SDL_FB_WIDTH * 4;  // 32位=4字节
    sdl_fb_info.screensize = SDL_FB_WIDTH * SDL_FB_HEIGHT * 4;
    
    // 清屏为白色
    for (int i = 0; i < SDL_FB_WIDTH * SDL_FB_HEIGHT; i++) {
        sdl_framebuffer[i] = COLOR_WHITE;
    }
    
    printf("[SDL Framebuffer] 内存framebuffer已初始化: %dx%d, 大小: %ld 字节\n", 
           SDL_FB_WIDTH, SDL_FB_HEIGHT, sdl_fb_info.screensize);
    
    // 检查SDL是否已初始化（SDL必须在主线程中初始化）
    if (SDL_WasInit(SDL_INIT_VIDEO) == 0) {
        printf("[SDL Framebuffer] 警告：SDL视频子系统未初始化，无法创建窗口\n");
        printf("[SDL Framebuffer] framebuffer已创建，但无法显示（需要SDL初始化）\n");
        return;
    }
    
    // 创建SDL覆盖窗口（用于显示绘图内容，覆盖在主窗口上）
    // 窗口大小：720x340（绘图区域），位置：0, 60
    // 注意：SDL窗口创建必须在主线程中进行（SDL不是线程安全的）
    printf("[SDL Framebuffer] 创建SDL覆盖窗口...\n");
    sdl_overlay_window = SDL_CreateWindow(
        "Remote Draw Overlay",
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
        720, 340,
        SDL_WINDOW_BORDERLESS | SDL_WINDOW_ALWAYS_ON_TOP
    );
    
    if (!sdl_overlay_window) {
        printf("[SDL Framebuffer] 创建覆盖窗口失败: %s\n", SDL_GetError());
        printf("[SDL Framebuffer] 警告：SDL窗口创建失败，framebuffer仍可用但无法显示\n");
        return;
    }
    
    printf("[SDL Framebuffer] SDL窗口创建成功\n");
    
    // 设置窗口透明度（可选）
    SDL_SetWindowOpacity(sdl_overlay_window, 1.0f);
    
    // 创建渲染器（优先使用软件渲染，更稳定）
    printf("[SDL Framebuffer] 创建SDL渲染器...\n");
    sdl_overlay_renderer = SDL_CreateRenderer(sdl_overlay_window, -1, SDL_RENDERER_SOFTWARE);
    if (!sdl_overlay_renderer) {
        printf("[SDL Framebuffer] 软件渲染器创建失败: %s\n", SDL_GetError());
        SDL_DestroyWindow(sdl_overlay_window);
        sdl_overlay_window = NULL;
        return;
    }
    
    // 设置渲染器背景色为白色
    SDL_SetRenderDrawColor(sdl_overlay_renderer, 255, 255, 255, 255);
    
    printf("[SDL Framebuffer] SDL渲染器创建成功\n");
    
    // 创建纹理（用于存储framebuffer内容）
    printf("[SDL Framebuffer] 创建SDL纹理...\n");
    sdl_overlay_texture = SDL_CreateTexture(
        sdl_overlay_renderer,
        SDL_PIXELFORMAT_ARGB8888,
        SDL_TEXTUREACCESS_STREAMING,
        720, 340
    );
    
    if (!sdl_overlay_texture) {
        printf("[SDL Framebuffer] 创建纹理失败: %s\n", SDL_GetError());
        SDL_DestroyRenderer(sdl_overlay_renderer);
        SDL_DestroyWindow(sdl_overlay_window);
        sdl_overlay_renderer = NULL;
        sdl_overlay_window = NULL;
        return;
    }
    
    printf("[SDL Framebuffer] SDL纹理创建成功\n");
    printf("[SDL Framebuffer] 覆盖窗口已创建: 720x340\n");
}

// 清理SDL虚拟framebuffer
static void sdl_fb_cleanup(void) {
    if (sdl_overlay_texture) {
        SDL_DestroyTexture(sdl_overlay_texture);
        sdl_overlay_texture = NULL;
    }
    if (sdl_overlay_renderer) {
        SDL_DestroyRenderer(sdl_overlay_renderer);
        sdl_overlay_renderer = NULL;
    }
    if (sdl_overlay_window) {
        SDL_DestroyWindow(sdl_overlay_window);
        sdl_overlay_window = NULL;
    }
    if (sdl_framebuffer) {
        free(sdl_framebuffer);
        sdl_framebuffer = NULL;
    }
    memset(&sdl_fb_info, 0, sizeof(sdl_fb_info));
}

// SDL刷新定时器回调：将framebuffer内容直接绘制到SDL覆盖窗口
static void sdl_refresh_timer_cb(lv_timer_t *t) {
    (void)t;
    if (!sdl_framebuffer || !sdl_overlay_window || !sdl_overlay_texture || !sdl_overlay_renderer) {
        return;
    }
    
    pthread_mutex_lock(&sdl_fb_mutex);
    
    // 锁定纹理进行写入
    void *texture_pixels;
    int texture_pitch;
    if (SDL_LockTexture(sdl_overlay_texture, NULL, &texture_pixels, &texture_pitch) != 0) {
        pthread_mutex_unlock(&sdl_fb_mutex);
        static int warn_count = 0;
        if (++warn_count % 100 == 0) {
            printf("[SDL刷新] 锁定纹理失败: %s\n", SDL_GetError());
        }
        return;
    }
    
    // 将framebuffer的绘图区域（x[0-720], y[60-400]）复制到纹理
    uint32_t *tex_pixels = (uint32_t*)texture_pixels;
    int tex_pitch_pixels = texture_pitch / 4;  // 转换为像素单位
    
    for (int y = 0; y < 340; y++) {
        int fb_y = y + 60;  // framebuffer y坐标
        for (int x = 0; x < 720; x++) {
            // 获取framebuffer像素（BGRA格式）
            uint32_t bgra = sdl_framebuffer[fb_y * SDL_FB_WIDTH + x];
            
            // 转换为ARGB格式（SDL纹理使用ARGB8888格式）
            // BGRA格式：B(字节0), G(字节1), R(字节2), A(字节3)
            // ARGB格式：A(字节0), R(字节1), G(字节2), B(字节3)
            uint32_t b = (bgra >> 0) & 0xFF;   // Blue (BGRA的字节0)
            uint32_t g = (bgra >> 8) & 0xFF;   // Green (BGRA的字节1)
            uint32_t r = (bgra >> 16) & 0xFF;  // Red (BGRA的字节2)
            uint32_t a = (bgra >> 24) & 0xFF;  // Alpha (BGRA的字节3)
            // 转换为ARGB格式：A(高位), R, G, B(低位)
            uint32_t argb = (a << 24) | (r << 16) | (g << 8) | b;
            
            // 写入纹理
            tex_pixels[y * tex_pitch_pixels + x] = argb;
        }
    }
    
    SDL_UnlockTexture(sdl_overlay_texture);
    pthread_mutex_unlock(&sdl_fb_mutex);
    
    // 清除渲染器并绘制纹理
    SDL_RenderClear(sdl_overlay_renderer);
    SDL_RenderCopy(sdl_overlay_renderer, sdl_overlay_texture, NULL, NULL);
    SDL_RenderPresent(sdl_overlay_renderer);
}

#endif  // USE_SDL
 
 // BGRA转ARGB函数（用于LVGL显示）
 static inline uint32_t bgra_to_argb(uint32_t bgra) {
     uint32_t b = (bgra >> 0) & 0xFF;   // Blue (低位)
     uint32_t g = (bgra >> 8) & 0xFF;   // Green
     uint32_t r = (bgra >> 16) & 0xFF;  // Red
     uint32_t a = (bgra >> 24) & 0xFF;  // Alpha (高位)
     // 转换为ARGB格式: [A][R][G][B]
     return (a << 24) | (r << 16) | (g << 8) | b;
 }
 
 // 保存按钮对象指针（用于更新选中状态）
 static lv_obj_t *pen_size_btns[3] = {NULL, NULL, NULL};  // 细、中、粗三个按钮
 static lv_obj_t *color_btns[6] = {NULL, NULL, NULL, NULL, NULL, NULL};  // 六个颜色按钮
 static lv_obj_t *eraser_btn = NULL;
 
 // 清除屏幕
 static void clear_screen(struct FramebufferInfo* fb, uint32_t color) {
     pthread_mutex_lock(&fb_mutex);
     uint32_t* fb_ptr = (uint32_t*)fb->fbp;
     for (int i = 0; i < fb->screensize / 4; i++) {
         fb_ptr[i] = color;
     }
     pthread_mutex_unlock(&fb_mutex);
 }
 
// 绘制一个像素点（需要加锁）
static void draw_pixel(struct FramebufferInfo* fb, int x, int y, uint32_t color) {
    if (x < 0 || x >= fb->vinfo.xres || y < 0 || y >= fb->vinfo.yres) {
        return;
    }
    
    pthread_mutex_lock(&fb_mutex);
    // 直接计算位置
    int offset = (y * fb->finfo.line_length) + (x * 4); // 32位=4字节
    *((uint32_t*)(fb->fbp + offset)) = color;
    pthread_mutex_unlock(&fb_mutex);
}

// 绘制一个像素点（不加锁版本，用于已经持有锁的情况）
static void draw_pixel_unlocked(struct FramebufferInfo* fb, int x, int y, uint32_t color) {
    if (x < 0 || x >= fb->vinfo.xres || y < 0 || y >= fb->vinfo.yres) {
        return;
    }
    
    // 直接计算位置（假设已经持有fb_mutex锁）
    int offset = (y * fb->finfo.line_length) + (x * 4); // 32位=4字节
    *((uint32_t*)(fb->fbp + offset)) = color;
}

// 绘制一个圆点（根据笔触大小，需要加锁）
static void draw_circle_point(struct FramebufferInfo* fb, int x, int y, uint32_t color, int radius) {
    // 根据半径绘制圆形区域
    for (int dy = -radius; dy <= radius; dy++) {
        for (int dx = -radius; dx <= radius; dx++) {
            // 检查是否在圆形内
            if (dx * dx + dy * dy <= radius * radius) {
                draw_pixel(fb, x + dx, y + dy, color);
            }
        }
    }
}

// 绘制一个圆点（不加锁版本，用于已经持有锁的情况）
static void draw_circle_point_unlocked(struct FramebufferInfo* fb, int x, int y, uint32_t color, int radius) {
    // 根据半径绘制圆形区域
    for (int dy = -radius; dy <= radius; dy++) {
        for (int dx = -radius; dx <= radius; dx++) {
            // 检查是否在圆形内
            if (dx * dx + dy * dy <= radius * radius) {
                draw_pixel_unlocked(fb, x + dx, y + dy, color);
            }
        }
    }
}
 
 // 绘制一条线（Bresenham算法）
 static void draw_line(struct FramebufferInfo* fb, int x0, int y0, int x1, int y1, uint32_t color) {
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
     int err = dx - dy;
     
     while (1) {
         draw_pixel(fb, x0, y0, color);
         
         if (x0 == x1 && y0 == y1) break;
         
         int e2 = 2 * err;
         if (e2 > -dy) {
             err -= dy;
             x0 += sx;
         }
         if (e2 < dx) {
             err += dx;
             y0 += sy;
         }
     }
 }
 
 // 协作绘图按钮对象（用于定时器更新UI）
 static lv_obj_t *collab_connect_btn = NULL;      // 连接协作按钮（主机）
 static lv_obj_t *collab_join_btn = NULL;         // 加入协作按钮（客机）
 static lv_obj_t *collab_end_btn = NULL;          // 结束协作按钮
 static lv_obj_t *back_btn = NULL;                 // 返回按钮
 static lv_timer_t *collab_status_check_timer = NULL;
 
 // 前向声明
 static void remote_draw_callback(uint16_t x, uint16_t y, uint16_t prev_x, uint16_t prev_y,
                                  uint8_t pen_size, uint32_t color, bool is_eraser, void *user_data);
 
 // 协作模式状态
 static bool is_host_mode = false;  // 是否是主机模式（开启协作）
 static bool is_guest_mode = false; // 是否是客机模式（加入协作）
 
 // 连接线程ID（用于检查线程状态）
 static pthread_t connect_thread = 0;
 static pthread_t join_thread = 0;
 
 // 检查协作连接状态的定时器回调
 static void collab_status_check_timer_cb(lv_timer_t *t) {
     if (!t) {
         return;
     }
     
     collaborative_draw_state_t state = collaborative_draw_get_state();
     
     if (is_host_mode && collab_connect_btn) {
         // 主机模式
         lv_obj_t *label = lv_obj_get_child(collab_connect_btn, 0);
         if (!label) {
             printf("[协作状态检查] 警告：无法获取按钮标签，跳过UI更新\n");
             return;
         }
         
         if (state == COLLAB_DRAW_STATE_CONNECTED) {
             printf("[协作状态检查] 连接成功，更新UI\n");
             lv_label_set_text(label, "已连接");
             lv_obj_set_style_bg_color(collab_connect_btn, lv_color_hex(0x4CAF50), 0);  // 绿色
             // 显示结束协作按钮
             if (collab_end_btn) {
                 lv_obj_clear_flag(collab_end_btn, LV_OBJ_FLAG_HIDDEN);
             }
             // 重置线程ID（连接成功，线程已退出）
             connect_thread = 0;
             if (t) {
                 lv_timer_del(t);
             }
             collab_status_check_timer = NULL;
         } else if (state == COLLAB_DRAW_STATE_ERROR || state == COLLAB_DRAW_STATE_DISCONNECTED) {
             lv_label_set_text(label, "连接失败");
             lv_obj_set_style_bg_color(collab_connect_btn, lv_color_hex(0xF44336), 0);  // 红色
             is_host_mode = false;
             // 重置线程ID（连接失败，线程已退出）
             connect_thread = 0;
             lv_timer_del(t);
             collab_status_check_timer = NULL;
         } else if (t->repeat_count++ > 100) {  // 100 * 100ms = 10秒超时
             lv_label_set_text(label, "连接超时");
             lv_obj_set_style_bg_color(collab_connect_btn, lv_color_hex(0xF44336), 0);
             is_host_mode = false;
             // 重置线程ID（超时，线程可能仍在运行，但允许重新连接）
             connect_thread = 0;
             lv_timer_del(t);
             collab_status_check_timer = NULL;
         }
     } else if (is_guest_mode && collab_join_btn) {
         // 客机模式
         lv_obj_t *label = lv_obj_get_child(collab_join_btn, 0);
         if (!label) {
             printf("[协作状态检查] 警告：无法获取按钮标签，跳过UI更新\n");
             return;
         }
         
         if (state == COLLAB_DRAW_STATE_CONNECTED) {
             printf("[协作状态检查] 加入成功，更新UI\n");
             lv_label_set_text(label, "已加入");
             lv_obj_set_style_bg_color(collab_join_btn, lv_color_hex(0x4CAF50), 0);  // 绿色
             // 显示结束协作按钮
             if (collab_end_btn) {
                 lv_obj_clear_flag(collab_end_btn, LV_OBJ_FLAG_HIDDEN);
             }
             // 连接成功，线程已退出，重置线程ID
             join_thread = 0;
             if (t) {
                 lv_timer_del(t);
             }
             collab_status_check_timer = NULL;
         } else if (state == COLLAB_DRAW_STATE_ERROR || state == COLLAB_DRAW_STATE_DISCONNECTED) {
             lv_label_set_text(label, "加入失败");
             lv_obj_set_style_bg_color(collab_join_btn, lv_color_hex(0xF44336), 0);  // 红色
             is_guest_mode = false;
             // 连接失败，重置线程ID（线程可能还在运行，但连接已失败）
             join_thread = 0;
             lv_timer_del(t);
             collab_status_check_timer = NULL;
         } else if (t->repeat_count++ > 100) {  // 100 * 100ms = 10秒超时
             lv_label_set_text(label, "搜索超时");
             lv_obj_set_style_bg_color(collab_join_btn, lv_color_hex(0xF44336), 0);
             is_guest_mode = false;
             // 连接超时，重置线程ID（允许重新连接）
             join_thread = 0;
             lv_timer_del(t);
             collab_status_check_timer = NULL;
         }
     } else {
         // 没有活动的按钮，删除定时器
         lv_timer_del(t);
         collab_status_check_timer = NULL;
     }
 }
 
 // 协作绘图连接线程函数（在后台线程中执行，避免UI卡顿）
static void* collaborative_connect_thread_func(void *arg) {
    pthread_t *thread_id_ptr = (pthread_t *)arg;
    
    printf("[触摸绘图] 连接线程启动\n");
    
    // 确保remote_draw_callback已设置（在start之前设置，因为start会清理之前的连接）
    collaborative_draw_set_remote_draw_callback(remote_draw_callback, NULL);
    printf("[触摸绘图] 连接线程：设置remote_draw_callback（连接前）\n");
    
    // 在后台线程中执行连接（避免UI卡顿）
    int ret = collaborative_draw_start();
    if (ret != 0) {
        printf("[触摸绘图] 连接线程：协作绘图启动失败 (ret=%d)\n", ret);
    } else {
        printf("[触摸绘图] 连接线程：协作绘图启动成功\n");
        // 连接成功后，再次确保回调被设置（因为start可能会清除回调）
        // 等待一小段时间，确保连接状态已更新
        usleep(100000);  // 100ms
        
        // 检查状态，确保连接成功
        collaborative_draw_state_t state = collaborative_draw_get_state();
        printf("[触摸绘图] 连接线程：当前状态=%d\n", state);
        
        if (state == COLLAB_DRAW_STATE_CONNECTED) {
            collaborative_draw_set_remote_draw_callback(remote_draw_callback, NULL);
            printf("[触摸绘图] 连接线程：重新设置remote_draw_callback（连接后）\n");
        } else {
            printf("[触摸绘图] 连接线程：警告：状态不是CONNECTED，跳过重新设置回调\n");
        }
    }
    
     // 连接完成后，重置线程ID
     if (thread_id_ptr) {
         *thread_id_ptr = 0;
     }
     
     printf("[触摸绘图] 连接线程退出\n");
     return NULL;
 }
 
 // 协作绘图连接按钮回调（作为主机开启协作）
 static void collaborative_connect_cb(lv_event_t *e) {
     if (lv_event_get_code(e) != LV_EVENT_CLICKED) {
         return;
     }
     
     lv_obj_t *btn = lv_event_get_target(e);
     lv_obj_t *label = lv_obj_get_child(btn, 0);
     collaborative_draw_state_t state = collaborative_draw_get_state();
     
     // 如果正在连接中，忽略点击（防止重复点击导致连接中断）
     if (state == COLLAB_DRAW_STATE_CONNECTING) {
         printf("[触摸绘图] 连接正在进行中，忽略重复点击\n");
         return;
     }
     
     // 如果协作模块未初始化，先初始化（可能在退出后重新进入）
     if (!collaborative_mode) {
         collaborative_draw_config_t collab_config = {0};
         collab_config.enabled = true;
         strncpy(collab_config.server_host, "bemfa.com",
                 sizeof(collab_config.server_host) - 1);
         collab_config.server_port = 8344;
         collab_config.user_id = (uint32_t)time(NULL) % 1000000;
         strncpy(collab_config.room_id, "default_room", sizeof(collab_config.room_id) - 1);
         strncpy(collab_config.device_name, COLLAB_DEVICE_NAME,
                 sizeof(collab_config.device_name) - 1);
         strncpy(collab_config.private_key, COLLAB_PRIVATE_KEY,
                 sizeof(collab_config.private_key) - 1);
         
         if (collaborative_draw_init(&collab_config) == 0) {
             collaborative_draw_set_remote_draw_callback(remote_draw_callback, NULL);
             collaborative_mode = true;
             printf("[触摸绘图] 协作绘图模块已重新初始化\n");
         } else {
             printf("[触摸绘图] 协作绘图模块初始化失败\n");
             return;
         }
     }
     
     // 如果已经是客机模式，先退出
     if (is_guest_mode) {
         collaborative_draw_stop();
         is_guest_mode = false;
     }
     
     if (collaborative_mode && state != COLLAB_DRAW_STATE_CONNECTED) {
         // 停止之前的检查定时器
         if (collab_status_check_timer) {
             lv_timer_del(collab_status_check_timer);
             collab_status_check_timer = NULL;
         }
         
         // 如果之前的连接线程还在运行，等待它退出
         if (connect_thread != 0) {
             int ret = pthread_kill(connect_thread, 0);
             if (ret == 0) {
                 // 线程还在运行，等待其退出（最多等待1秒）
                 printf("[触摸绘图] 等待之前的连接线程退出...\n");
                 for (int i = 0; i < 10; i++) {
                     usleep(100000);  // 100ms
                     ret = pthread_kill(connect_thread, 0);
                     if (ret != 0) {
                         // 线程已退出
                         break;
                     }
                 }
                 if (ret == 0) {
                     // 线程仍在运行，强制重置（可能是卡住了）
                     printf("[触摸绘图] 连接线程超时，强制重置\n");
                 }
             }
             // 重置线程ID（无论线程是否还在运行）
             connect_thread = 0;
         }
         
         // 确保之前的状态已清理
         if (state == COLLAB_DRAW_STATE_DISCONNECTED || state == COLLAB_DRAW_STATE_ERROR) {
             collaborative_draw_stop();
             collaborative_draw_cleanup();
             // 等待一下确保资源释放
             usleep(50000);  // 50ms
         }
         
         // 启动协作绘图连接（作为主机，在后台线程中执行，避免UI卡顿）
         is_host_mode = true;
         lv_label_set_text(label, "连接中...");
         lv_obj_set_style_bg_color(btn, lv_color_hex(0xFFA500), 0);  // 橙色
         collab_connect_btn = btn;
         
         // 更新其他按钮状态
         if (collab_join_btn) {
             lv_obj_set_style_bg_color(collab_join_btn, lv_color_hex(0x9E9E9E), 0);
         }
         if (collab_end_btn) {
             lv_obj_add_flag(collab_end_btn, LV_OBJ_FLAG_HIDDEN);
         }
         
        // 在后台线程中执行连接（传递线程ID指针，以便线程退出时重置）
        // 注意：pthread_create的第一个参数和第四个参数不能是同一个对象（restrict限制）
        // 所以先创建线程，然后传递线程ID的地址
        pthread_t thread_id;
        pthread_t *thread_id_ptr = &thread_id;
        if (pthread_create(&thread_id, NULL, collaborative_connect_thread_func, thread_id_ptr) != 0) {
            printf("[触摸绘图] 创建连接线程失败\n");
            lv_label_set_text(label, "连接失败");
            lv_obj_set_style_bg_color(btn, lv_color_hex(0xF44336), 0);  // 红色
            is_host_mode = false;
            connect_thread = 0;
            return;
        }
        connect_thread = thread_id;  // 保存线程ID
         // 不detach，让线程自然退出后可以被join
         
         // 使用定时器检查连接状态并更新UI（每100ms检查一次）
         collab_status_check_timer = lv_timer_create(collab_status_check_timer_cb, 100, NULL);
     } else if (state == COLLAB_DRAW_STATE_CONNECTED && is_host_mode) {
         // 已连接，断开（主机模式）
         // 停止检查定时器
         if (collab_status_check_timer) {
             lv_timer_del(collab_status_check_timer);
             collab_status_check_timer = NULL;
         }
         
         // 断开连接
         collaborative_draw_stop();
         collaborative_draw_cleanup();
         is_host_mode = false;
         // 重置线程ID
         connect_thread = 0;
         lv_label_set_text(label, "连接协作");
         lv_obj_set_style_bg_color(btn, lv_color_hex(0x4CAF50), 0);  // 绿色
         
         // 恢复其他按钮
         if (collab_join_btn) {
             lv_obj_set_style_bg_color(collab_join_btn, lv_color_hex(0x2196F3), 0);
         }
         if (collab_end_btn) {
             lv_obj_add_flag(collab_end_btn, LV_OBJ_FLAG_HIDDEN);
         }
         
         collab_connect_btn = NULL;
         printf("[触摸绘图] 协作绘图模式已断开（主机）\n");
     } else {
         // 如果状态不是CONNECTED，检查是否是连接失败后的状态
         if (state == COLLAB_DRAW_STATE_ERROR || state == COLLAB_DRAW_STATE_DISCONNECTED) {
             // 连接失败或已断开，重置状态
             is_host_mode = false;
             connect_thread = 0;
             lv_label_set_text(label, "连接协作");
             lv_obj_set_style_bg_color(btn, lv_color_hex(0x4CAF50), 0);  // 绿色
         } else {
             lv_label_set_text(label, "未启用");
             lv_obj_set_style_bg_color(btn, lv_color_hex(0x9E9E9E), 0);  // 灰色
         }
     }
 }
 
 // 加入协作按钮回调（作为客机加入他人的协作）
 static void collaborative_join_cb(lv_event_t *e) {
     if (lv_event_get_code(e) != LV_EVENT_CLICKED) {
         return;
     }
     
     lv_obj_t *btn = lv_event_get_target(e);
     lv_obj_t *label = lv_obj_get_child(btn, 0);
     collaborative_draw_state_t state = collaborative_draw_get_state();
     
     // 如果正在连接中，忽略点击（防止重复点击导致连接中断）
     if (state == COLLAB_DRAW_STATE_CONNECTING) {
         printf("[触摸绘图] 连接正在进行中，忽略重复点击\n");
         return;
     }
     
     // 如果已经是主机模式，先退出
     if (is_host_mode) {
         collaborative_draw_stop();
         is_host_mode = false;
     }
     
     if (collaborative_mode && state != COLLAB_DRAW_STATE_CONNECTED) {
         // 停止之前的检查定时器
         if (collab_status_check_timer) {
             lv_timer_del(collab_status_check_timer);
             collab_status_check_timer = NULL;
         }
         
         // 如果之前的加入线程还在运行，等待它退出
         if (join_thread != 0) {
             int ret = pthread_kill(join_thread, 0);
             if (ret == 0) {
                 // 线程还在运行，等待其退出（最多等待1秒）
                 printf("[触摸绘图] 等待之前的加入线程退出...\n");
                 for (int i = 0; i < 10; i++) {
                     usleep(100000);  // 100ms
                     ret = pthread_kill(join_thread, 0);
                     if (ret != 0) {
                         // 线程已退出
                         break;
                     }
                 }
                 if (ret == 0) {
                     // 线程仍在运行，强制重置（可能是卡住了）
                     printf("[触摸绘图] 加入线程超时，强制重置\n");
                 }
             }
             // 重置线程ID（无论线程是否还在运行）
             join_thread = 0;
         }
         
         // 确保之前的状态已清理
         if (state == COLLAB_DRAW_STATE_DISCONNECTED || state == COLLAB_DRAW_STATE_ERROR) {
             collaborative_draw_stop();
             collaborative_draw_cleanup();
             // 等待一下确保资源释放
             usleep(50000);  // 50ms
         }
         
         // 启动协作绘图连接（作为客机）
         is_guest_mode = true;
         lv_label_set_text(label, "搜索中...");
         lv_obj_set_style_bg_color(btn, lv_color_hex(0xFFA500), 0);  // 橙色
         collab_join_btn = btn;
         
         // 更新其他按钮状态
         if (collab_connect_btn) {
             lv_obj_set_style_bg_color(collab_connect_btn, lv_color_hex(0x9E9E9E), 0);
         }
         if (collab_end_btn) {
             lv_obj_clear_flag(collab_end_btn, LV_OBJ_FLAG_HIDDEN);
         }
         
        // 在后台线程中执行连接（传递线程ID指针，以便线程退出时重置）
        // 注意：pthread_create的第一个参数和第四个参数不能是同一个对象（restrict限制）
        // 所以先创建线程，然后传递线程ID的地址
        pthread_t thread_id;
        pthread_t *thread_id_ptr = &thread_id;
        if (pthread_create(&thread_id, NULL, collaborative_connect_thread_func, thread_id_ptr) != 0) {
            printf("[触摸绘图] 创建加入线程失败\n");
            lv_label_set_text(label, "加入失败");
            lv_obj_set_style_bg_color(btn, lv_color_hex(0xF44336), 0);  // 红色
            is_guest_mode = false;
            join_thread = 0;
            return;
        }
        join_thread = thread_id;  // 保存线程ID
         // 不detach，让线程自然退出后可以被join
         
         // 使用定时器检查连接状态并更新UI
         collab_status_check_timer = lv_timer_create(collab_status_check_timer_cb, 100, NULL);
     } else if (state == COLLAB_DRAW_STATE_CONNECTED && is_guest_mode) {
         // 已连接，断开（客机模式）
         if (collab_status_check_timer) {
             lv_timer_del(collab_status_check_timer);
             collab_status_check_timer = NULL;
         }
         
         collaborative_draw_stop();
         collaborative_draw_cleanup();
         is_guest_mode = false;
         // 重置线程ID
         join_thread = 0;
         lv_label_set_text(label, "加入协作");
         lv_obj_set_style_bg_color(btn, lv_color_hex(0x2196F3), 0);  // 蓝色
         
         // 恢复其他按钮
         if (collab_connect_btn) {
             lv_obj_set_style_bg_color(collab_connect_btn, lv_color_hex(0x4CAF50), 0);
         }
         if (collab_end_btn) {
             lv_obj_add_flag(collab_end_btn, LV_OBJ_FLAG_HIDDEN);
         }
         
         collab_join_btn = NULL;
         printf("[触摸绘图] 协作绘图模式已断开（客机）\n");
     } else if (state == COLLAB_DRAW_STATE_ERROR || state == COLLAB_DRAW_STATE_DISCONNECTED) {
         // 连接失败或已断开，重置状态
         is_guest_mode = false;
         join_thread = 0;
         lv_label_set_text(label, "加入协作");
         lv_obj_set_style_bg_color(btn, lv_color_hex(0x2196F3), 0);  // 蓝色
     }
 }
 
 // 结束协作按钮回调（结束主机或客机的协作）
 static void collaborative_end_cb(lv_event_t *e) {
     if (lv_event_get_code(e) != LV_EVENT_CLICKED) {
         return;
     }
     
     // 停止检查定时器
     if (collab_status_check_timer) {
         lv_timer_del(collab_status_check_timer);
         collab_status_check_timer = NULL;
     }
     
     // 断开连接
     collaborative_draw_stop();
     collaborative_draw_cleanup();
     
     // 重置状态
     is_host_mode = false;
     is_guest_mode = false;
     // 重置线程ID
     connect_thread = 0;
     join_thread = 0;
     
     // 更新按钮状态
     if (collab_connect_btn) {
         lv_obj_t *label = lv_obj_get_child(collab_connect_btn, 0);
         lv_label_set_text(label, "连接协作");
         lv_obj_set_style_bg_color(collab_connect_btn, lv_color_hex(0x4CAF50), 0);  // 绿色
     }
     if (collab_join_btn) {
         lv_obj_t *label = lv_obj_get_child(collab_join_btn, 0);
         lv_label_set_text(label, "加入协作");
         lv_obj_set_style_bg_color(collab_join_btn, lv_color_hex(0x2196F3), 0);  // 蓝色
     }
     if (collab_end_btn) {
         lv_obj_add_flag(collab_end_btn, LV_OBJ_FLAG_HIDDEN);
     }
     
     printf("[触摸绘图] 协作绘图已结束\n");
 }
 
 // 返回主页回调
 static bool back_button_processing = false;  // 防止重复处理
 
 static void touch_draw_back_cb(lv_event_t *e) {
     if (lv_event_get_code(e) != LV_EVENT_CLICKED) {
         return;
     }
     
     // 防止重复处理
     if (back_button_processing) {
         printf("[触摸绘图] 返回按钮正在处理中，忽略重复点击\n");
         return;
     }
     
     back_button_processing = true;
     printf("[触摸绘图] 返回按钮被点击，开始清理资源\n");
     
     // 先停止触摸绘图（这会停止线程并清理资源）
     touch_draw_cleanup();
     
     // 等待一段时间，确保所有资源都已清理完成
     usleep(100000);  // 100ms
     
     // 多次处理LVGL定时器，确保所有清理操作都完成
     for (int i = 0; i < 10; i++) {
         lv_timer_handler();
         usleep(10000);  // 10ms
     }
     
     // 返回到进入时的页面
     extern lv_obj_t* get_main_page1_screen(void);
     extern lv_obj_t* get_main_page2_screen(void);
     extern void switch_to_page(int);
     extern int get_current_page_index(void);
     
     // 确保两个页面都正确显示/隐藏
     lv_obj_t *page1_screen = get_main_page1_screen();
     lv_obj_t *page2_screen = get_main_page2_screen();
     
     if (page1_screen && page2_screen) {
         int current = get_current_page_index();
         
         // 如果当前页面和目标页面不同，使用switch_to_page切换（会处理隐藏逻辑）
         if (current != saved_page_index) {
             switch_to_page(saved_page_index);
         } else {
             // 当前页面已经是目标页面，确保另一个页面被隐藏
             if (saved_page_index == 0) {
                 // 目标是页面1，确保页面2被隐藏
                 lv_obj_add_flag(page2_screen, LV_OBJ_FLAG_HIDDEN);
                 lv_obj_clear_flag(page1_screen, LV_OBJ_FLAG_HIDDEN);
                 lv_scr_load(page1_screen);
             } else {
                 // 目标是页面2，确保页面1被隐藏
                 lv_obj_add_flag(page1_screen, LV_OBJ_FLAG_HIDDEN);
                 lv_obj_clear_flag(page2_screen, LV_OBJ_FLAG_HIDDEN);
                 lv_scr_load(page2_screen);
             }
         }
         
         // 多次处理定时器，确保页面切换完成
         for (int i = 0; i < 15; i++) {
             lv_timer_handler();
             usleep(10000);  // 10ms
         }
         
         // 强制刷新显示
         lv_refr_now(NULL);
         printf("[触摸绘图] 返回到页面 %d\n", saved_page_index);
     }
     
     // 重置标志，允许再次处理
     back_button_processing = false;
 }
 
 // 笔触大小选择回调（通过用户数据传递大小索引）
 static void pen_size_select_cb(lv_event_t *e) {
     if (lv_event_get_code(e) != LV_EVENT_CLICKED) {
         return;
     }
     
     lv_obj_t *btn = lv_event_get_target(e);
     int size_idx = (int)(intptr_t)lv_obj_get_user_data(btn);
     pen_size = size_idx + 1;  // 1=细，2=中，3=粗
     printf("[触摸绘图] 笔触大小切换为: %d\n", pen_size);
     
     // 更新所有笔触大小按钮的选中状态
     for (int i = 0; i < 3; i++) {
         if (pen_size_btns[i]) {
             if (i == size_idx) {
                 // 选中状态：深色边框
                 lv_obj_set_style_border_width(pen_size_btns[i], 3, 0);
                 lv_obj_set_style_border_color(pen_size_btns[i], lv_color_hex(0x0000FF), 0);
             } else {
                 // 未选中状态：浅色边框
                 lv_obj_set_style_border_width(pen_size_btns[i], 2, 0);
                 lv_obj_set_style_border_color(pen_size_btns[i], lv_color_hex(0xCCCCCC), 0);
             }
         }
     }
 }
 
 // 颜色选择回调（通过用户数据传递颜色索引）
 static void color_select_cb(lv_event_t *e) {
     if (lv_event_get_code(e) != LV_EVENT_CLICKED) {
         return;
     }
     
     lv_obj_t *btn = lv_event_get_target(e);
     int color_idx = (int)(intptr_t)lv_obj_get_user_data(btn);
     current_color_index = color_idx;
     
     // 退出橡皮擦模式
     eraser_mode = false;
     if (eraser_btn) {
         lv_obj_set_style_bg_color(eraser_btn, lv_color_hex(0xFFFFFF), 0);
         lv_obj_set_style_border_color(eraser_btn, lv_color_hex(0xCCCCCC), 0);
     }
     
     printf("[触摸绘图] 颜色切换为: %d\n", current_color_index);
     
     // 更新所有颜色按钮的选中状态
     for (int i = 0; i < color_count; i++) {
         if (color_btns[i]) {
             if (i == color_idx) {
                 // 选中状态：加粗边框
                 lv_obj_set_style_border_width(color_btns[i], 4, 0);
                 lv_obj_set_style_border_color(color_btns[i], lv_color_hex(0x000000), 0);
             } else {
                 // 未选中状态：细边框
                 lv_obj_set_style_border_width(color_btns[i], 2, 0);
                 lv_obj_set_style_border_color(color_btns[i], lv_color_hex(0xCCCCCC), 0);
             }
         }
     }
 }
 
 // 橡皮擦切换回调
 static void eraser_toggle_cb(lv_event_t *e) {
     if (lv_event_get_code(e) != LV_EVENT_CLICKED) {
         return;
     }
     
     eraser_mode = !eraser_mode;
     printf("[触摸绘图] 橡皮擦模式: %s\n", eraser_mode ? "开启" : "关闭");
     
     // 更新按钮样式
     lv_obj_t *btn = lv_event_get_target(e);
     if (eraser_mode) {
         lv_obj_set_style_bg_color(btn, lv_color_hex(0xFFE0E0), 0);  // 浅红色表示激活
         lv_obj_set_style_border_width(btn, 3, 0);
         lv_obj_set_style_border_color(btn, lv_color_hex(0xFF0000), 0);  // 红色边框
     } else {
         lv_obj_set_style_bg_color(btn, lv_color_hex(0xFFFFFF), 0);  // 白色表示未激活
         lv_obj_set_style_border_width(btn, 2, 0);
         lv_obj_set_style_border_color(btn, lv_color_hex(0xCCCCCC), 0);  // 灰色边框
     }
 }
 
// 调试日志控制（可以通过编译选项控制）
#ifndef REMOTE_DRAW_DEBUG
    #define REMOTE_DRAW_DEBUG 0  // 0=禁用详细日志，1=启用详细日志
#endif

// 绘制同步频率控制（毫秒）
#define DRAW_SYNC_INTERVAL_MS 8   // 约120fps，每8ms同步一次（提高频率以保证线条连续性）
#define DRAW_BATCH_SIZE 5         // 批量处理的最大绘制操作数（减少批量大小以保证及时显示）
#define DRAW_MIN_INTERVAL_MS 0    // 最小处理间隔（毫秒），0表示不跳过任何消息（保证连续性）
#define DRAW_MAX_STEPS 500        // 最大步数限制（增加步数以绘制更平滑的线条）

// 远程绘图回调（接收其他用户的绘图操作）
static void remote_draw_callback(uint16_t x, uint16_t y, uint16_t prev_x, uint16_t prev_y,
                                 uint8_t remote_pen_size, uint32_t color, bool is_eraser, void *user_data) {
    (void)user_data;
    (void)is_eraser;  // 暂时未使用
    
    static int call_count = 0;
    static struct timespec last_sync_time = {0, 0};
    static struct timespec last_process_time = {0, 0};  // 上次处理时间（用于频率限制）
    static int pending_draws = 0;
    call_count++;
    
    // 频率限制：如果消息太频繁，跳过一些中间消息（减少处理量）
    struct timespec current_process_time;
    clock_gettime(CLOCK_MONOTONIC, &current_process_time);
    if (last_process_time.tv_sec != 0) {
        // 计算时间差（毫秒）
        long elapsed_ms = (current_process_time.tv_sec - last_process_time.tv_sec) * 1000 +
                         (current_process_time.tv_nsec - last_process_time.tv_nsec) / 1000000;
        
        // 如果间隔太短，跳过本次处理（避免处理过多消息）
        // 注意：DRAW_MIN_INTERVAL_MS=0时，不跳过任何消息，保证线条连续性
        if (DRAW_MIN_INTERVAL_MS > 0 && elapsed_ms < DRAW_MIN_INTERVAL_MS) {
            static int skip_freq_count = 0;
            if (REMOTE_DRAW_DEBUG && ++skip_freq_count % 200 == 0) {
                printf("[远程绘图] 频率限制：跳过过快消息（已跳过%d次）\n", skip_freq_count);
            }
            return;
        }
    }
    last_process_time = current_process_time;
    
    // 减少调试日志输出（每50次打印一次，减小日志开销）
    if (REMOTE_DRAW_DEBUG && call_count % 50 == 0) {
        printf("[远程绘图] 收到绘制操作 #%d: x=%d, y=%d, prev_x=%d, prev_y=%d, pen_size=%d, color=0x%08X\n",
               call_count, x, y, prev_x, prev_y, remote_pen_size, color);
    }
    
    // 检查pen_size是否有效（pen_size=0且color=0xFFFFFFFF表示清屏操作）
    if (remote_pen_size == 0) {
        if (color == 0xFFFFFFFF) {
            // 清屏操作
            bool fb_available = (fb_info.fd >= 0 && fb_info.fbp && fb_info.fbp != MAP_FAILED && 
                                 fb_info.screensize > 0);
            if (fb_available) {
                // 清屏framebuffer（保留顶部和底部工具栏）
                if (pthread_mutex_trylock(&fb_mutex) == 0) {
                    uint32_t* fb_ptr = (uint32_t*)fb_info.fbp;
                    int top_bar = 60;      // 顶部区域
                    int bottom_bar = 80;   // 底部工具栏
                    int right_bar = 80;    // 右侧工具栏
                    int right_start_x = fb_info.vinfo.xres - right_bar;
                    
                    // 只清空中间绘图区域（排除顶部、底部和右侧工具栏）
                    for (int y = top_bar; y < fb_info.vinfo.yres - bottom_bar; y++) {
                        for (int x = 0; x < right_start_x; x++) {
                            fb_ptr[y * (fb_info.finfo.line_length / 4) + x] = COLOR_WHITE;
                        }
                    }
                    
                    // 同步到framebuffer（清屏操作立即同步）
                    msync(fb_info.fbp, fb_info.screensize, MS_SYNC);
                    pthread_mutex_unlock(&fb_mutex);
                    printf("[远程绘图] framebuffer清屏完成\n");
                } else {
                    printf("[远程绘图] 无法获取framebuffer锁，跳过清屏\n");
                }
            }
        } else {
            printf("[远程绘图] 警告：pen_size=0但color不是清屏标志，跳过绘制（可能是无效数据）\n");
        }
        return;
    }
    
    // 检查坐标是否在绘图区域内（排除工具栏）
    // 注意：y < 60 是工具栏区域，但如果是有效的绘制操作，坐标应该在绘图区域内
    if (y < 60 || y >= 400 || (x >= 720 && y >= 60 && y < 340)) {
        if (REMOTE_DRAW_DEBUG && call_count % 50 == 0) {
            printf("[远程绘图] 坐标在工具栏区域，跳过: x=%d, y=%d\n", x, y);
        }
        return;  // 在工具栏区域，不绘制
    }
    
    // 检查framebuffer是否可用（开发板设备）
    bool fb_available = (fb_info.fd >= 0 && fb_info.fbp && fb_info.fbp != MAP_FAILED && 
                         fb_info.screensize > 0);
    
    if (fb_available) {
        // 使用framebuffer绘制（开发板设备）
        // 检查坐标是否在framebuffer范围内
        if (x >= (uint16_t)fb_info.vinfo.xres || y >= (uint16_t)fb_info.vinfo.yres) {
            if (REMOTE_DRAW_DEBUG) {
                printf("[远程绘图] 坐标超出framebuffer范围: x=%d (max=%d), y=%d (max=%d)\n",
                       x, fb_info.vinfo.xres, y, fb_info.vinfo.yres);
            }
            return;
        }
        
        // 尝试加锁，如果失败则返回（避免死锁和阻塞）
        if (pthread_mutex_trylock(&fb_mutex) != 0) {
            // 如果无法获取锁，跳过本次绘制（避免阻塞网络线程）
            // 使用静态计数器减少日志输出
            static int skip_count = 0;
            if (REMOTE_DRAW_DEBUG && ++skip_count % 500 == 0) {  // 降低日志频率
                printf("[远程绘图] 无法获取framebuffer锁，跳过绘制（已跳过%d次）\n", skip_count);
            }
            return;
        }
        
        // 再次检查framebuffer有效性
        if (fb_info.fd < 0 || !fb_info.fbp || fb_info.fbp == MAP_FAILED || fb_info.fbp == NULL) {
            pthread_mutex_unlock(&fb_mutex);
            return;
        }
        
        int radius = remote_pen_size;
        uint32_t draw_color = color;
        
        // 绘制远程用户的绘图操作（使用不加锁版本，因为已经持有fb_mutex锁）
        if (prev_x == x && prev_y == y) {
            // 单点
            draw_circle_point_unlocked(&fb_info, x, y, draw_color, radius);
        } else {
            // 线条
            int dx = abs((int)x - (int)prev_x);
            int dy = abs((int)y - (int)prev_y);
            int steps = (dx > dy ? dx : dy) + 1;
            
            // 限制步数，防止过大循环（优化：进一步减少最大步数以提高性能）
            if (steps > DRAW_MAX_STEPS) {
                steps = DRAW_MAX_STEPS;  // 减少最大步数，提高绘制速度
            }
            
            for (int i = 0; i <= steps; i++) {
                int px = prev_x + (int)(((int)x - (int)prev_x) * i / steps);
                int py = prev_y + (int)(((int)y - (int)prev_y) * i / steps);
                
                // 再次检查坐标有效性
                if (px >= 0 && px < fb_info.vinfo.xres && py >= 0 && py < fb_info.vinfo.yres) {
                    draw_circle_point_unlocked(&fb_info, px, py, draw_color, radius);
                }
            }
        }
        
        // 批量处理绘制操作，减少msync调用频率
        pending_draws++;
        bool need_sync = false;
        
        // 检查是否需要同步（时间间隔或批量大小）
        struct timespec current_time;
        clock_gettime(CLOCK_MONOTONIC, &current_time);
        
        if (last_sync_time.tv_sec == 0) {
            // 首次同步
            last_sync_time = current_time;
            need_sync = true;
        } else {
            // 计算时间差（毫秒）
            long elapsed_ms = (current_time.tv_sec - last_sync_time.tv_sec) * 1000 +
                             (current_time.tv_nsec - last_sync_time.tv_nsec) / 1000000;
            
            // 如果超过同步间隔或达到批量大小，则同步
            if (elapsed_ms >= DRAW_SYNC_INTERVAL_MS || pending_draws >= DRAW_BATCH_SIZE) {
                need_sync = true;
                last_sync_time = current_time;
                pending_draws = 0;
            }
        }
        
        if (need_sync) {
            // 同步到framebuffer（使用MS_SYNC同步同步，保证立即显示，减少断续感）
            if (fb_info.fbp && fb_info.fbp != MAP_FAILED && fb_info.screensize > 0) {
                msync(fb_info.fbp, fb_info.screensize, MS_SYNC);  // 使用同步同步，保证立即显示
            }
            
            if (REMOTE_DRAW_DEBUG && call_count % 50 == 0) {
                printf("[远程绘图] 批量同步完成: 已绘制到framebuffer (x=%d, y=%d, radius=%d)\n",
                       x, y, radius);
            }
        }
        
        pthread_mutex_unlock(&fb_mutex);
    } else {
        // framebuffer不可用（可能是未初始化或已关闭）
        printf("[远程绘图] framebuffer不可用: fd=%d, fbp=%p, screensize=%ld\n",
               fb_info.fd, fb_info.fbp, fb_info.screensize);
        
        // 虚拟机(SDL)环境：使用framebuffer方式绘制（与开发板相同）
#if USE_SDL
        // 注意：SDL操作必须在主线程中进行，不能在网络线程中初始化SDL窗口
        // framebuffer应该在窗口显示时（主线程）已经初始化
        if (!sdl_framebuffer) {
            // 如果framebuffer未初始化，说明窗口还未显示，跳过绘制
            static int warn_count = 0;
            if (++warn_count % 10 == 0) {  // 改为每10条打印一次，更容易看到
                printf("[远程绘图] 警告：framebuffer未初始化，跳过绘制（应在主线程中初始化）\n");
            }
            return;
        }
        
        // 调试：确认framebuffer已初始化
        static int init_log_count = 0;
        if (++init_log_count % 50 == 0) {
            printf("[远程绘图] framebuffer已初始化，开始绘制\n");
        }
        
        // 直接绘制到framebuffer（使用与开发板相同的逻辑）
        if (pthread_mutex_lock(&sdl_fb_mutex) != 0) {
            printf("[远程绘图] 错误：无法锁定framebuffer互斥锁\n");
            return;
        }
        
        // 颜色格式转换：接收到的颜色可能是ARGB格式（0xFFFF0000），需要转换为BGRA格式
        // 根据协议定义，color字段应该是BGRA格式，但实际接收到的可能是ARGB格式
        // 检查：如果颜色值看起来像ARGB格式（高位是Alpha，次高位是Red），则转换
        // ARGB格式：0xAARRGGBB (Alpha, Red, Green, Blue)
        // BGRA格式：0xAARRGGBB (但内存布局是: Blue, Green, Red, Alpha)
        // 对于uint32_t值，BGRA格式应该是：0xAARRGGBB，其中：
        //   字节0(低位): B (blue)
        //   字节1: G (green)
        //   字节2: R (red)
        //   字节3(高位): A (alpha)
        // 所以0xFFFF0000 (ARGB红色) 应该转换为 0xFF0000FF (BGRA红色)
        uint32_t draw_color;
        // 简单判断：如果颜色值的高位字节是0xFF且红色字节（字节2）是0xFF，可能是ARGB格式
        // 更通用的方法：总是尝试转换（如果已经是BGRA，转换后还是正确的）
        draw_color = argb_to_bgra(color);
        
        // 调试：显示颜色转换（每20条打印一次）
        static int color_log_count = 0;
        if (++color_log_count % 20 == 0) {
            printf("[远程绘图] 颜色转换: 原始=0x%08X, 转换后=0x%08X\n", color, draw_color);
        }
        int radius = remote_pen_size;
        
        // 坐标转换：智能检测坐标类型
        // 开发板发送的是屏幕坐标（800x480），虚拟机发送的是触摸坐标（1024x600）
        // 通过坐标范围判断：如果坐标在800x480范围内，当作屏幕坐标直接使用
        // 如果坐标在1024x600范围内，当作触摸坐标进行转换
        int screen_x, screen_y, screen_prev_x, screen_prev_y;
        
        // 判断坐标类型：如果坐标在屏幕坐标范围内（800x480），直接使用
        // 否则当作触摸坐标（1024x600）进行转换
        if (x <= SCREEN_WIDTH && y <= SCREEN_HEIGHT && 
            prev_x <= SCREEN_WIDTH && prev_y <= SCREEN_HEIGHT) {
            // 屏幕坐标（开发板发送）：直接使用，但需要限制在有效范围内
            screen_x = (x < 0) ? 0 : (x >= SDL_FB_WIDTH ? SDL_FB_WIDTH - 1 : x);
            screen_y = (y < 0) ? 0 : (y >= SDL_FB_HEIGHT ? SDL_FB_HEIGHT - 1 : y);
            screen_prev_x = (prev_x < 0) ? 0 : (prev_x >= SDL_FB_WIDTH ? SDL_FB_WIDTH - 1 : prev_x);
            screen_prev_y = (prev_y < 0) ? 0 : (prev_y >= SDL_FB_HEIGHT ? SDL_FB_HEIGHT - 1 : prev_y);
        } else {
            // 触摸坐标（虚拟机发送）：需要转换
            // 触摸坐标范围：X[0-1024], Y[0-600]
            // 屏幕坐标范围：X[0-800], Y[0-480]
            int touch_max_x_remote = 1024;
            int touch_max_y_remote = 600;
            int touch_min_x_remote = 0;
            int touch_min_y_remote = 0;
            
            // 转换坐标（使用整数运算避免浮点误差）
            screen_x = (int)((x - touch_min_x_remote) * SDL_FB_WIDTH / (touch_max_x_remote - touch_min_x_remote));
            screen_y = (int)((y - touch_min_y_remote) * SDL_FB_HEIGHT / (touch_max_y_remote - touch_min_y_remote));
            screen_prev_x = (int)((prev_x - touch_min_x_remote) * SDL_FB_WIDTH / (touch_max_x_remote - touch_min_x_remote));
            screen_prev_y = (int)((prev_y - touch_min_y_remote) * SDL_FB_HEIGHT / (touch_max_y_remote - touch_min_y_remote));
        }
        
        // 限制坐标在有效范围内
        if (screen_x < 0) screen_x = 0;
        if (screen_x >= SDL_FB_WIDTH) screen_x = SDL_FB_WIDTH - 1;
        if (screen_y < 0) screen_y = 0;
        if (screen_y >= SDL_FB_HEIGHT) screen_y = SDL_FB_HEIGHT - 1;
        if (screen_prev_x < 0) screen_prev_x = 0;
        if (screen_prev_x >= SDL_FB_WIDTH) screen_prev_x = SDL_FB_WIDTH - 1;
        if (screen_prev_y < 0) screen_prev_y = 0;
        if (screen_prev_y >= SDL_FB_HEIGHT) screen_prev_y = SDL_FB_HEIGHT - 1;
        
        // 检查prev_x和prev_y是否有效（防止绘制异常长线）
        bool is_valid_prev_point = true;
        
        // 情况1：如果prev_x和prev_y都是0，且当前点不是(0,0)，说明这是第一个点或无效的上一个点
        if (prev_x == 0 && prev_y == 0 && (x != 0 || y != 0)) {
            is_valid_prev_point = false;
        }
        
        // 情况2：如果转换后的screen_prev_x和screen_prev_y都是0，且当前点不是(0,0)，也当作第一个点
        if (screen_prev_x == 0 && screen_prev_y == 0 && (screen_x != 0 || screen_y != 0)) {
            is_valid_prev_point = false;
        }
        
        // 情况3：如果prev_x和prev_y与当前点相同，说明是单点（开发板第一个点会这样发送）
        if (prev_x == x && prev_y == y) {
            is_valid_prev_point = false;  // 单点，不需要绘制线条
        }
        
        // 情况4：如果转换后的坐标相同，也是单点
        if (screen_prev_x == screen_x && screen_prev_y == screen_y) {
            is_valid_prev_point = false;
        }
        
        // 计算转换后的坐标距离
        int dx = abs(screen_x - screen_prev_x);
        int dy = abs(screen_y - screen_prev_y);
        
        // 情况5：如果距离过大（超过屏幕尺寸的5%），可能是坐标转换错误或异常数据，当作单点处理
        // 非常严格的阈值：800*5%=40, 480*5%=24
        // 正常绘制时，两点之间的距离应该不会超过这个值（除非用户快速移动手指）
        if (is_valid_prev_point && (dx > SDL_FB_WIDTH / 20 || dy > SDL_FB_HEIGHT / 20)) {
            is_valid_prev_point = false;
            if (REMOTE_DRAW_DEBUG && call_count % 50 == 0) {
                printf("[远程绘图] 警告：坐标距离过大，当作单点处理: dx=%d (max=%d), dy=%d (max=%d), 原始(%d,%d)->(%d,%d)\n", 
                       dx, SDL_FB_WIDTH / 20, dy, SDL_FB_HEIGHT / 20, prev_x, prev_y, x, y);
            }
        }
        
        // 调试日志（每5条打印一次，显示坐标转换和绘制信息）
        static int coord_log_counter = 0;
        if (REMOTE_DRAW_DEBUG && ++coord_log_counter % 5 == 0) {
            printf("[远程绘图] 坐标转换: 触摸(%d,%d)->(%d,%d) -> 屏幕(%d,%d)->(%d,%d), 有效=%d, 颜色=0x%08X, 笔触=%d\n",
                   prev_x, prev_y, x, y, screen_prev_x, screen_prev_y, screen_x, screen_y, 
                   is_valid_prev_point ? 1 : 0, draw_color, radius);
        }
        
        // 如果prev点无效，当作单点处理
        if (!is_valid_prev_point || (screen_prev_x == screen_x && screen_prev_y == screen_y)) {
            // 单点绘制
            if (screen_x >= 0 && screen_x < SDL_FB_WIDTH && screen_y >= 0 && screen_y < SDL_FB_HEIGHT) {
                // 根据半径绘制圆形区域
                for (int ddy = -radius; ddy <= radius; ddy++) {
                    for (int ddx = -radius; ddx <= radius; ddx++) {
                        // 检查是否在圆形内
                        if (ddx * ddx + ddy * ddy <= radius * radius) {
                            int fx = screen_x + ddx;
                            int fy = screen_y + ddy;
                            // 检查边界
                            if (fx >= 0 && fx < SDL_FB_WIDTH && fy >= 0 && fy < SDL_FB_HEIGHT) {
                                sdl_framebuffer[fy * SDL_FB_WIDTH + fx] = draw_color;
                            }
                        }
                    }
                }
            }
            pthread_mutex_unlock(&sdl_fb_mutex);
            return;
        }
        
        // 计算步数（限制最大步数，防止异常长线）
        int steps = (dx > dy ? dx : dy) + 1;
        // 限制步数：如果超过屏幕尺寸的30%，可能是异常数据
        int max_steps = (SDL_FB_WIDTH > SDL_FB_HEIGHT ? SDL_FB_WIDTH : SDL_FB_HEIGHT) * 3 / 10;
        if (steps > max_steps) {
            steps = max_steps;
            if (REMOTE_DRAW_DEBUG && call_count % 50 == 0) {
                printf("[远程绘图] 警告：步数过大，限制为%d\n", max_steps);
            }
        }
        
        // 绘制线条上的每个点
        int pixels_drawn = 0;  // 统计绘制的像素数
        for (int i = 0; i <= steps; i++) {
            int px = screen_prev_x + (int)((screen_x - screen_prev_x) * i / steps);
            int py = screen_prev_y + (int)((screen_y - screen_prev_y) * i / steps);
            
            // 检查坐标有效性
            if (px >= 0 && px < SDL_FB_WIDTH && py >= 0 && py < SDL_FB_HEIGHT) {
                // 直接绘制到framebuffer（不使用draw_circle_point，避免死锁）
                // 根据半径绘制圆形区域
                for (int ddy = -radius; ddy <= radius; ddy++) {
                    for (int ddx = -radius; ddx <= radius; ddx++) {
                        // 检查是否在圆形内
                        if (ddx * ddx + ddy * ddy <= radius * radius) {
                            int fx = px + ddx;
                            int fy = py + ddy;
                            // 检查边界
                            if (fx >= 0 && fx < SDL_FB_WIDTH && fy >= 0 && fy < SDL_FB_HEIGHT) {
                                sdl_framebuffer[fy * SDL_FB_WIDTH + fx] = draw_color;
                                pixels_drawn++;
                            }
                        }
                    }
                }
            }
        }
        
        // 调试：显示绘制的像素数
        static int pixel_log_counter = 0;
        if (++pixel_log_counter % 10 == 0) {
            printf("[远程绘图] 本次绘制了 %d 个像素点\n", pixels_drawn);
        }
        
        pthread_mutex_unlock(&sdl_fb_mutex);
        
        // 添加调试日志（每10条打印一次）
        static int log_counter = 0;
        if (++log_counter % 10 == 0) {
            printf("[远程绘图] 已绘制到framebuffer: 触摸坐标(%d, %d) -> (%d, %d), 屏幕坐标(%d, %d) -> (%d, %d), 颜色=0x%08X, 笔触=%d\n",
                   prev_x, prev_y, x, y, screen_prev_x, screen_prev_y, screen_x, screen_y, color, remote_pen_size);
        }
#else
        // 非SDL构建且framebuffer不可用：无法绘制
        (void)remote_pen_size;
        (void)color;
#endif
    }
}
 
 // 清屏回调
 static void clear_screen_cb(lv_event_t *e) {
     if (lv_event_get_code(e) != LV_EVENT_CLICKED) {
         return;
     }
     
    printf("[触摸绘图] 清屏\n");
    
#if USE_SDL
    // SDL虚拟机模式：清屏SDL framebuffer
    if (sdl_framebuffer) {
        pthread_mutex_lock(&sdl_fb_mutex);
        // 清屏绘图区域（保留顶部、底部和右侧工具栏）
        int top_bar = 60;      // 顶部区域
        int bottom_bar = 80;   // 底部工具栏
        int right_bar = 80;    // 右侧工具栏
        int right_start_x = SDL_FB_WIDTH - right_bar;
        // 只清空中间绘图区域（排除右侧工具栏）
        for (int y = top_bar; y < SDL_FB_HEIGHT - bottom_bar; y++) {
            for (int x = 0; x < right_start_x; x++) {
                sdl_framebuffer[y * SDL_FB_WIDTH + x] = COLOR_WHITE;
            }
        }
        pthread_mutex_unlock(&sdl_fb_mutex);
        printf("[触摸绘图] SDL framebuffer清屏完成\n");
        
        // 如果启用协作模式，发送清屏操作到服务器
        if (collaborative_mode) {
            collaborative_draw_send_clear();
        }
        
        // 刷新LVGL显示，确保按钮位置正确
        lv_refr_now(NULL);
        return;
    }
#else
    // 在主线程中清屏framebuffer
    // 如果线程已经运行，使用已映射的framebuffer
    if (fb_info.fbp && fb_info.fbp != MAP_FAILED) {
         pthread_mutex_lock(&fb_mutex);
         uint32_t* fb_ptr = (uint32_t*)fb_info.fbp;
         // 清屏绘图区域（保留顶部、底部和右侧工具栏）
         int top_bar = 60;      // 顶部区域
         int bottom_bar = 80;   // 底部工具栏
         int right_bar = 80;    // 右侧工具栏
         int right_start_x = fb_info.vinfo.xres - right_bar;
         // 只清空中间绘图区域（排除右侧工具栏）
         for (int y = top_bar; y < fb_info.vinfo.yres - bottom_bar; y++) {
             for (int x = 0; x < right_start_x; x++) {
                 int pixel_idx = y * fb_info.vinfo.xres + x;
                 fb_ptr[pixel_idx] = COLOR_WHITE;
             }
         }
         msync(fb_info.fbp, fb_info.screensize, MS_SYNC);
         pthread_mutex_unlock(&fb_mutex);
         printf("[触摸绘图] 清屏完成\n");
         
         // 如果启用协作模式，发送清屏操作到服务器
         if (collaborative_mode) {
             collaborative_draw_send_clear();
         }
         
         // 刷新LVGL显示，确保按钮位置正确
         lv_refr_now(NULL);
     } else {
         // 如果framebuffer还未映射，直接打开并清屏
         int fb_fd = open(FRAMEBUFFER_DEV, O_RDWR);
         if (fb_fd >= 0) {
             struct fb_var_screeninfo vinfo;
             struct fb_fix_screeninfo finfo;
             
             if (ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo) == 0 &&
                 ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo) == 0) {
                 long int screensize = vinfo.yres * finfo.line_length;
                 char *fbp = (char *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0);
                 
                 if ((intptr_t)fbp != -1) {
                     uint32_t* fb_ptr = (uint32_t*)fbp;
                     int top_bar = 60;      // 顶部区域
                     int bottom_bar = 80;   // 底部工具栏
                     int right_bar = 80;    // 右侧工具栏
                     int right_start_x = vinfo.xres - right_bar;
                     // 只清空中间绘图区域（排除右侧工具栏）
                     for (int y = top_bar; y < vinfo.yres - bottom_bar; y++) {
                         for (int x = 0; x < right_start_x; x++) {
                             int pixel_idx = y * vinfo.xres + x;
                             fb_ptr[pixel_idx] = COLOR_WHITE;
                         }
                     }
                     msync(fbp, screensize, MS_SYNC);
                     munmap(fbp, screensize);
                     printf("[触摸绘图] 清屏完成（临时映射）\n");
                 }
             }
             close(fb_fd);
         }
     }
#endif  // USE_SDL
 }
 
 // 触摸绘图线程函数
 static void* touch_draw_thread_func(void* arg) {
     struct input_event ev;
     enum TouchState touch_state = TOUCH_IDLE;
     
     // 触摸坐标和上一个触摸坐标（用于画线）
     int touch_x = 0, touch_y = 0;
     int last_screen_x = 0, last_screen_y = 0;
     int is_first_point = 1;
     
     printf("[触摸绘图] 线程启动\n");
     
     // 打开触摸屏设备
     touch_fd = open(TOUCH_DEVICE, O_RDONLY);
     if (touch_fd == -1) {
         perror("[触摸绘图] Error opening touch device");
         touch_draw_running = false;
         return NULL;
     }
     
     // 初始化帧缓冲区
     fb_info.fd = open(FRAMEBUFFER_DEV, O_RDWR);
     if (fb_info.fd == -1) {
         perror("[触摸绘图] Error opening framebuffer");
         close(touch_fd);
         touch_fd = -1;
         touch_draw_running = false;
         return NULL;
     }
     
     // 获取屏幕信息
     if (ioctl(fb_info.fd, FBIOGET_FSCREENINFO, &fb_info.finfo)) {
         perror("[触摸绘图] Error reading fixed framebuffer info");
         close(touch_fd);
         close(fb_info.fd);
         touch_fd = -1;
         touch_draw_running = false;
         return NULL;
     }
     
     if (ioctl(fb_info.fd, FBIOGET_VSCREENINFO, &fb_info.vinfo)) {
         perror("[触摸绘图] Error reading variable framebuffer info");
         close(touch_fd);
         close(fb_info.fd);
         touch_fd = -1;
         touch_draw_running = false;
         return NULL;
     }
     
     printf("[触摸绘图] Framebuffer info:\n");
     printf("  Resolution: %dx%d\n", fb_info.vinfo.xres, fb_info.vinfo.yres);
     printf("  Bits per pixel: %d\n", fb_info.vinfo.bits_per_pixel);
     printf("  Line length: %d bytes\n", fb_info.finfo.line_length);
     
     // 映射帧缓冲区到内存
     fb_info.screensize = fb_info.vinfo.yres * fb_info.finfo.line_length;
     fb_info.fbp = (char*)mmap(0, fb_info.screensize, 
                              PROT_READ | PROT_WRITE, 
                              MAP_SHARED, fb_info.fd, 0);
     
     if (fb_info.fbp == MAP_FAILED) {
         perror("[触摸绘图] Error mapping framebuffer");
         close(touch_fd);
         close(fb_info.fd);
         touch_fd = -1;
         touch_draw_running = false;
         return NULL;
     }
     
     // 等待一小段时间，确保LVGL完成初始渲染
     usleep(200000);  // 200ms，确保LVGL完成窗口显示
     
     // 清屏为白色（只清屏顶部、底部和右侧工具栏以外的区域）
     // 注意：主线程已经清屏过了，这里只是为了确保，或者处理线程重新启动的情况
     pthread_mutex_lock(&fb_mutex);
     uint32_t* fb_ptr = (uint32_t*)fb_info.fbp;
     int top_bar = 60;      // 顶部区域
     int bottom_bar = 80;   // 底部工具栏
     int right_bar = 80;    // 右侧工具栏
     int right_start_x = fb_info.vinfo.xres - right_bar;
     // 只清空中间绘图区域（排除右侧工具栏）
     for (int y = top_bar; y < fb_info.vinfo.yres - bottom_bar; y++) {
         for (int x = 0; x < right_start_x; x++) {
             int pixel_idx = y * fb_info.vinfo.xres + x;
             fb_ptr[pixel_idx] = COLOR_WHITE;
         }
     }
     msync(fb_info.fbp, fb_info.screensize, MS_SYNC);
     pthread_mutex_unlock(&fb_mutex);
     
     printf("[触摸绘图] Framebuffer已清屏为白色（保留顶部区域）\n");
     printf("[触摸绘图] 触摸绘图程序已启动\n");
     printf("  Screen size: %dx%d\n", SCREEN_WIDTH, SCREEN_HEIGHT);
     printf("  Touch range: X[%d-%d], Y[%d-%d]\n", 
            touch_min_x, touch_max_x, touch_min_y, touch_max_y);
     
     // 主事件循环
     while (touch_draw_running) {
         // 检查文件描述符是否有效
         if (touch_fd < 0) {
             printf("[触摸绘图] 触摸设备文件描述符无效，退出线程\n");
             break;
         }
         
         // 读取触摸事件
         ssize_t n = read(touch_fd, &ev, sizeof(struct input_event));
         if (n == -1) {
             if (errno == EAGAIN || errno == EWOULDBLOCK) {
                 usleep(10000);  // 等待10ms
                 continue;
             }
             if (errno == EINTR) {
                 // 被信号中断，继续
                 continue;
             }
             // 如果文件描述符无效，说明已被关闭，退出线程
             if (errno == EBADF) {
                 printf("[触摸绘图] 触摸设备文件描述符已关闭，退出线程\n");
                 break;
             }
             perror("[触摸绘图] Error reading touch event");
             break;
         }
         
         if (n != sizeof(struct input_event)) {
             continue;
         }
         
         // 处理触摸事件
         if (ev.type == EV_ABS) {
             if (ev.code == ABS_X) {
                 touch_x = ev.value;
             }
             if (ev.code == ABS_Y) {
                 touch_y = ev.value;
             }
         }
         else if (ev.type == EV_KEY && ev.code == BTN_TOUCH) {
             // 在按下时就检查是否在工具栏区域
             if (ev.value) {  // 触摸按下
                 // 先检查触摸位置是否在工具栏区域
                 int screen_x, screen_y;
                 screen_x = (touch_x - touch_min_x) * SCREEN_WIDTH / (touch_max_x - touch_min_x);
                 screen_y = (touch_y - touch_min_y) * SCREEN_HEIGHT / (touch_max_y - touch_min_y);
                 
                 // 边界检查
                 if (screen_x < 0) screen_x = 0;
                 if (screen_x >= SCREEN_WIDTH) screen_x = SCREEN_WIDTH - 1;
                 if (screen_y < 0) screen_y = 0;
                 if (screen_y >= SCREEN_HEIGHT) screen_y = SCREEN_HEIGHT - 1;
                 
                 // 检查是否在工具栏区域（顶部、底部、右侧）
                 // 按钮布局：
                 // - 返回按钮：x=[10,90], y=[10,50], 大小80x40
                 // - 连接协作按钮：x=[100,200], y=[10,50], 大小100x40
                 // - 加入协作按钮：x=[210,310], y=[10,50], 大小100x40
                 // - 结束协作按钮：x=[320,420], y=[10,50], 大小100x40（可能隐藏）
                 bool in_toolbar = false;
                 if (screen_y < 60) {
                     // 左上角区域（返回按钮）：x=[10,90], y=[10,50]
                     if (screen_x >= 10 && screen_x < 90 && screen_y >= 10 && screen_y < 50) {
                         in_toolbar = true;
                     }
                     // 连接协作按钮区域：x=[100,200], y=[10,50]
                     else if (screen_x >= 100 && screen_x < 200 && screen_y >= 10 && screen_y < 50) {
                         in_toolbar = true;
                     }
                     // 加入协作按钮区域：x=[210,310], y=[10,50]
                     else if (screen_x >= 210 && screen_x < 310 && screen_y >= 10 && screen_y < 50) {
                         in_toolbar = true;
                     }
                     // 结束协作按钮区域：x=[320,420], y=[10,50]
                     else if (screen_x >= 320 && screen_x < 420 && screen_y >= 10 && screen_y < 50) {
                         in_toolbar = true;
                     }
                     // 其他顶部区域不算工具栏（允许绘制）
                     else {
                         in_toolbar = false;
                     }
                 }
                 // 底部工具栏：400-479像素（480-80=400），包括颜色按钮区域
                 else if (screen_y >= 400) {
                     in_toolbar = true;
                 }
                 // 右侧工具栏：720-799像素（800-80=720），高度280像素（从60像素开始到340像素）
                 else if (screen_x >= 720 && screen_y >= 60 && screen_y < 340) {
                     in_toolbar = true;
                 }
                 
                 if (in_toolbar) {
                     // 在工具栏区域，需要让LVGL处理按钮点击
                     // 手动触发按钮点击事件（不改变touch_draw_running，避免影响连接线程）
                     printf("[触摸绘图] Touch in toolbar area, processing button click: (%d, %d)\n", screen_x, screen_y);
                     
                     // 检查是哪个按钮被点击
                     lv_obj_t *clicked_btn = NULL;
                     if (screen_x >= 10 && screen_x < 90 && screen_y >= 10 && screen_y < 50) {
                         // 返回按钮
                         clicked_btn = back_btn;
                         printf("[触摸绘图] 返回按钮被点击\n");
                     } else if (screen_x >= 100 && screen_x < 200 && screen_y >= 10 && screen_y < 50) {
                         // 连接协作按钮
                         clicked_btn = collab_connect_btn;
                     } else if (screen_x >= 210 && screen_x < 310 && screen_y >= 10 && screen_y < 50) {
                         // 加入协作按钮
                         clicked_btn = collab_join_btn;
                     } else if (screen_x >= 320 && screen_x < 420 && screen_y >= 10 && screen_y < 50) {
                         // 结束协作按钮
                         clicked_btn = collab_end_btn;
                     }
                     
                     // 如果找到了按钮，手动触发点击事件
                     if (clicked_btn && !lv_obj_has_flag(clicked_btn, LV_OBJ_FLAG_HIDDEN)) {
                         // 先处理LVGL定时器，确保事件系统就绪
                         for (int i = 0; i < 3; i++) {
                             lv_timer_handler();
                             usleep(5000);  // 5ms
                         }
                         
                         // 发送PRESSED事件（模拟按下）
                         lv_event_send(clicked_btn, LV_EVENT_PRESSED, NULL);
                         lv_timer_handler();
                         
                         // 等待一下，模拟真实的按下-释放间隔
                         usleep(50000);  // 50ms
                         
                         // 发送RELEASED事件（模拟释放）
                         lv_event_send(clicked_btn, LV_EVENT_RELEASED, NULL);
                         lv_timer_handler();
                         
                         // 发送CLICKED事件（最终点击事件）
                         lv_event_send(clicked_btn, LV_EVENT_CLICKED, NULL);
                         
                         // 多次处理定时器，确保所有事件回调都被执行
                         for (int i = 0; i < 10; i++) {
                             lv_timer_handler();
                             usleep(5000);  // 5ms
                         }
                         
                         // 刷新显示，确保UI更新
                         lv_refr_now(NULL);
                         
                         printf("[触摸绘图] 按钮点击事件已触发并处理\n");
                     }
                     
                     // 快速跳过后续的触摸事件，避免阻塞
                     // 最多读取几个事件，如果没找到释放事件就继续（避免长时间阻塞）
                     struct input_event next_ev;
                     int release_found = 0;
                     int max_events = 10;  // 最多读取10个事件
                     while (touch_draw_running && !release_found && max_events-- > 0) {
                         ssize_t n_read = read(touch_fd, &next_ev, sizeof(struct input_event));
                         if (n_read < 0) {
                             if (errno == EAGAIN || errno == EWOULDBLOCK) {
                                 // 没有更多事件，退出循环
                                 break;
                             }
                             // 如果文件描述符无效，退出（可能已被关闭）
                             if (errno == EBADF) {
                                 break;
                             }
                             break;
                         }
                         
                         // 检查是否是触摸释放事件
                         if (next_ev.type == EV_KEY && next_ev.code == BTN_TOUCH && next_ev.value == 0) {
                             release_found = 1;
                             printf("[触摸绘图] 按钮区域触摸已释放\n");
                             break;
                         }
                         
                         // 如果是SYN_REPORT事件，也需要处理
                         if (next_ev.type == EV_SYN && next_ev.code == SYN_REPORT) {
                             // 继续等待释放事件
                             continue;
                         }
                     }
                     
                     // 如果没有找到释放事件，继续处理（避免阻塞）
                     if (!release_found) {
                         printf("[触摸绘图] 按钮区域事件已跳过\n");
                     }
                     
                     continue;
                 }
                 
                 touch_state = TOUCH_PRESSED;
                 printf("[触摸绘图] Touch pressed at: (%d, %d)\n", touch_x, touch_y);
                 
                 // 记录第一个点
                 is_first_point = 1;
             } else {        // 触摸释放
                 touch_state = TOUCH_IDLE;
                 printf("[触摸绘图] Touch released\n");
             }
         }
         else if (ev.type == EV_SYN && ev.code == SYN_REPORT) {
             // 同步事件，可以在这里进行绘制
             if (touch_state == TOUCH_PRESSED || touch_state == TOUCH_MOVING) {
                 // 将触摸坐标映射到屏幕坐标
                 int screen_x, screen_y;
                 
                 // X轴映射：触摸范围 [0, 1024] -> 屏幕范围 [0, 800]
                 screen_x = (touch_x - touch_min_x) * SCREEN_WIDTH / (touch_max_x - touch_min_x);
                 
                 // Y轴映射：触摸范围 [0, 600] -> 屏幕范围 [0, 480]
                 screen_y = (touch_y - touch_min_y) * SCREEN_HEIGHT / (touch_max_y - touch_min_y);
                 
                 // 边界检查
                 if (screen_x < 0) screen_x = 0;
                 if (screen_x >= SCREEN_WIDTH) screen_x = SCREEN_WIDTH - 1;
                 if (screen_y < 0) screen_y = 0;
                 if (screen_y >= SCREEN_HEIGHT) screen_y = SCREEN_HEIGHT - 1;
                 
                 // 再次检查是否在工具栏区域（顶部、底部、右侧）- 如果在工具栏区域则不绘制
                 // 按钮布局：
                 // - 返回按钮：x=[10,90], y=[10,50], 大小80x40
                 // - 连接协作按钮：x=[100,200], y=[10,50], 大小100x40
                 // - 加入协作按钮：x=[210,310], y=[10,50], 大小100x40
                 // - 结束协作按钮：x=[320,420], y=[10,50], 大小100x40（可能隐藏）
                 bool in_toolbar = false;
                 if (screen_y < 60) {
                     // 左上角区域（返回按钮）：x=[10,90], y=[10,50]
                     if (screen_x >= 10 && screen_x < 90 && screen_y >= 10 && screen_y < 50) {
                         in_toolbar = true;
                     }
                     // 连接协作按钮区域：x=[100,200], y=[10,50]
                     else if (screen_x >= 100 && screen_x < 200 && screen_y >= 10 && screen_y < 50) {
                         in_toolbar = true;
                     }
                     // 加入协作按钮区域：x=[210,310], y=[10,50]
                     else if (screen_x >= 210 && screen_x < 310 && screen_y >= 10 && screen_y < 50) {
                         in_toolbar = true;
                     }
                     // 结束协作按钮区域：x=[320,420], y=[10,50]
                     else if (screen_x >= 320 && screen_x < 420 && screen_y >= 10 && screen_y < 50) {
                         in_toolbar = true;
                     }
                     // 其他顶部区域不算工具栏（允许绘制）
                     else {
                         in_toolbar = false;
                     }
                 }
                 // 底部工具栏：400-479像素（480-80=400），包括颜色按钮区域
                 else if (screen_y >= 400) {
                     in_toolbar = true;
                 }
                 // 右侧工具栏：720-799像素（800-80=720），高度280像素（从60像素开始到340像素）
                 else if (screen_x >= 720 && screen_y >= 60 && screen_y < 340) {
                     in_toolbar = true;
                 }
                 
                 if (in_toolbar) {
                     // 在工具栏区域，不绘制，重置触摸状态并跳过
                     touch_state = TOUCH_IDLE;
                     continue;
                 }
                 
                 // 获取当前绘制颜色（橡皮擦模式使用白色，否则使用当前选择的颜色）
                 uint32_t draw_color = eraser_mode ? COLOR_WHITE : color_list[current_color_index];
                 
                 // 根据笔触大小决定绘制方式
                 int radius = pen_size;  // 1=细(半径1), 2=中(半径2), 3=粗(半径3)
                 
                // 保存is_first_point状态（在绘制前），用于发送数据时判断
                bool was_first_point = is_first_point;
                
                // 绘制点
                if (is_first_point) {
                    // 如果是第一个点，绘制一个圆点
                    draw_circle_point(&fb_info, screen_x, screen_y, draw_color, radius);
                    is_first_point = 0;
                } else {
                    // 绘制从上一点到当前点的线，使用粗线条（根据笔触大小）
                    // 对于粗线条，在线上每隔一段距离绘制一个圆点
                    int dx = abs(screen_x - last_screen_x);
                    int dy = abs(screen_y - last_screen_y);
                    int steps = (dx > dy ? dx : dy) + 1;
                    
                    for (int i = 0; i <= steps; i++) {
                        int px = last_screen_x + (screen_x - last_screen_x) * i / steps;
                        int py = last_screen_y + (screen_y - last_screen_y) * i / steps;
                        draw_circle_point(&fb_info, px, py, draw_color, radius);
                    }
                }
                
                // 同步framebuffer到显示（确保绘制立即显示，已加锁保护）
                pthread_mutex_lock(&fb_mutex);
                msync(fb_info.fbp, fb_info.screensize, MS_SYNC);
                pthread_mutex_unlock(&fb_mutex);
                
               // 如果启用协作模式，发送绘图操作到服务器（检查连接状态，避免崩溃）
               if (collaborative_mode && collaborative_draw_get_state() == COLLAB_DRAW_STATE_CONNECTED) {
                   // 如果是第一个点，prev_x和prev_y应该与当前点相同（单点）
                   // 否则使用上一个点的坐标
                   // 注意：检查last_screen_x和last_screen_y是否为0，如果是0且当前点不是0，也当作第一个点
                   int send_prev_x, send_prev_y;
                   if (was_first_point || (last_screen_x == 0 && last_screen_y == 0 && (screen_x != 0 || screen_y != 0))) {
                       // 第一个点：发送相同的坐标
                       send_prev_x = screen_x;
                       send_prev_y = screen_y;
                   } else {
                       // 非第一个点：使用上一个点的坐标
                       send_prev_x = last_screen_x;
                       send_prev_y = last_screen_y;
                   }
                    
                    // 静默发送，失败不影响本地绘制
                    int send_ret = collaborative_draw_send_operation(
                        screen_x, screen_y,
                        send_prev_x, send_prev_y,
                        pen_size, draw_color, eraser_mode);
                     // 如果发送失败，可能是连接已断开，切换到正常模式
                     if (send_ret != 0 && collaborative_draw_get_state() == COLLAB_DRAW_STATE_DISCONNECTED) {
                         printf("[触摸绘图] 协作绘图连接已断开，切换到正常模式\n");
                         collaborative_mode = false;
                         // 更新按钮状态
                         if (collab_connect_btn) {
                             lv_label_set_text(lv_obj_get_child(collab_connect_btn, 0), "连接协作");
                             lv_obj_set_style_bg_color(collab_connect_btn, lv_color_hex(0x2196F3), 0);  // 蓝色
                         }
                     }
                 }
                 
                 // 更新上一个点的坐标
                 last_screen_x = screen_x;
                 last_screen_y = screen_y;
                 
                 touch_state = TOUCH_MOVING;
             }
         }
     }
     
     // 清理资源
     printf("[触摸绘图] 清理资源...\n");
     if (fb_info.fbp != MAP_FAILED && fb_info.fbp != NULL) {
         munmap(fb_info.fbp, fb_info.screensize);
         fb_info.fbp = NULL;
     }
     if (touch_fd >= 0) {
         close(touch_fd);
         touch_fd = -1;
     }
     if (fb_info.fd >= 0) {
         close(fb_info.fd);
         fb_info.fd = -1;
     }
     
     printf("[触摸绘图] 线程退出\n");
     return NULL;
 }
 
 /**
  * @brief 显示触摸绘图窗口
  */
 void touch_draw_win_show(void) {
     extern const lv_font_t SourceHanSansSC_VF;
     
    if (touch_draw_window != NULL) {
        // 先确保触摸绘图模式未激活，允许LVGL正常刷新整个窗口
        touch_draw_running = false;
        
        // 确保remote_draw_callback已设置（重要！）
        collaborative_draw_set_remote_draw_callback(remote_draw_callback, NULL);
        printf("[触摸绘图] 重新设置remote_draw_callback\n");
        
        lv_obj_clear_flag(touch_draw_window, LV_OBJ_FLAG_HIDDEN);
        lv_scr_load(touch_draw_window);
        
        // 等待LVGL完成渲染整个窗口（包括按钮和标题）
        for (int i = 0; i < 20; i++) {
            lv_timer_handler();
            usleep(10000);  // 10ms
        }
        lv_refr_now(NULL);
        
        // 额外等待，确保LVGL刷新完成
        usleep(50000);  // 50ms

#if USE_SDL
        // SDL虚拟机模式：使用framebuffer方式绘制（与开发板相同）
        // 初始化虚拟framebuffer和SDL窗口（必须在主线程中进行，SDL不是线程安全的）
        if (!sdl_framebuffer) {
            printf("[触摸绘图] 初始化SDL framebuffer和窗口（主线程）...\n");
            sdl_fb_init();
            
            if (!sdl_framebuffer) {
                printf("[触摸绘图] 错误：SDL framebuffer初始化失败\n");
            } else {
                printf("[触摸绘图] SDL framebuffer初始化成功\n");
            }
        }
        
        // 创建SDL刷新定时器（如果不存在）
        if (!sdl_refresh_timer) {
            sdl_refresh_timer = lv_timer_create(sdl_refresh_timer_cb, 16, NULL);  // 60fps
            printf("[触摸绘图] SDL刷新定时器已创建，周期16ms（framebuffer -> SDL窗口）\n");
        } else {
            printf("[触摸绘图] SDL刷新定时器已存在\n");
        }
        
        // 显示SDL覆盖窗口（必须在主线程中进行）
        if (sdl_overlay_window) {
            SDL_ShowWindow(sdl_overlay_window);
            // 设置窗口位置（在主窗口的(0, 60)位置）
            SDL_SetWindowPosition(sdl_overlay_window, 0, 60);
            printf("[触摸绘图] SDL覆盖窗口已显示: 720x340, 位置(0, 60)\n");
        } else {
            printf("[触摸绘图] 警告：SDL覆盖窗口未创建，轨迹将无法显示\n");
        }
        
        // 启动SDL鼠标输入处理线程（实现双向绘制）
        if (!sdl_mouse_thread_running && sdl_framebuffer) {
            sdl_mouse_thread_running = true;
            if (pthread_create(&sdl_mouse_thread, NULL, sdl_mouse_thread_func, NULL) == 0) {
                printf("[触摸绘图] SDL鼠标输入线程已启动（支持双向绘制）\n");
            } else {
                printf("[触摸绘图] 警告：SDL鼠标输入线程启动失败\n");
                sdl_mouse_thread_running = false;
            }
        }
        
        touch_draw_running = false;
#else
        // 在LVGL刷新完成后，再设置触摸绘图模式为激活（禁用LVGL刷新）
        touch_draw_running = true;
        printf("[触摸绘图] 触摸绘图模式已激活，LVGL刷新已禁用\n");
        // （以下 framebuffer 清屏 + 触摸线程逻辑保持原样）
#endif
        return;
    }
     
     // 创建窗口
     touch_draw_window = lv_obj_create(NULL);
     lv_obj_set_size(touch_draw_window, 800, 480);
#if USE_SDL
    // SDL虚拟机模式：使用正常不透明背景（不依赖framebuffer直绘）
    lv_obj_set_style_bg_color(touch_draw_window, lv_color_hex(0xFFFFFF), 0);
    lv_obj_set_style_bg_opa(touch_draw_window, LV_OPA_COVER, 0);
    lv_obj_set_style_border_opa(touch_draw_window, LV_OPA_TRANSP, 0);
#else
    // 使用透明背景，让framebuffer直接显示，避免LVGL刷新覆盖
    lv_obj_set_style_bg_opa(touch_draw_window, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_opa(touch_draw_window, LV_OPA_TRANSP, 0);
#endif
     
     // 创建标题
     lv_obj_t *title = lv_label_create(touch_draw_window);
     lv_label_set_text(title, "触摸绘图");
     lv_obj_set_style_text_font(title, &SourceHanSansSC_VF, 0);
     lv_obj_set_style_text_color(title, lv_color_hex(0x000000), 0);  // 黑色文字（白色背景）
     lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 10);
     
     // 创建返回按钮（同一层级，不使用move_foreground）
     back_btn = lv_btn_create(touch_draw_window);
     lv_obj_set_size(back_btn, 80, 40);
     lv_obj_set_style_bg_color(back_btn, lv_color_hex(0x9E9E9E), 0);
     lv_obj_align(back_btn, LV_ALIGN_TOP_LEFT, 10, 10);
     lv_obj_t *back_label = lv_label_create(back_btn);
     lv_label_set_text(back_label, "返回");
     lv_obj_set_style_text_font(back_label, &SourceHanSansSC_VF, 0);
     lv_obj_center(back_label);
     lv_obj_add_event_cb(back_btn, touch_draw_back_cb, LV_EVENT_CLICKED, NULL);
     
     // 创建底部工具栏容器（左侧用于颜色选择）- 同一层级
     lv_obj_t *toolbar = lv_obj_create(touch_draw_window);
     lv_obj_set_size(toolbar, 800, 80);
     lv_obj_align(toolbar, LV_ALIGN_BOTTOM_MID, 0, 0);
     lv_obj_set_style_bg_color(toolbar, lv_color_hex(0xF5F5F5), 0);
     lv_obj_set_style_border_width(toolbar, 2, 0);
     lv_obj_set_style_border_color(toolbar, lv_color_hex(0xCCCCCC), 0);
     lv_obj_set_style_pad_all(toolbar, 8, 0);
     
     // 工具栏按钮参数
     int btn_size = 60;  // 按钮大小（正方形）
     int btn_spacing = 10;
     int start_x = 20;  // 工具栏起始位置
     
     // 创建6个颜色按钮（水平排列在底部工具栏）
     // ARGB颜色（用于LVGL显示）
     uint32_t colors_lvgl[] = {
         0xFFFF0000,  // 红色
         0xFF00FF00,  // 绿色
         0xFF0000FF,  // 蓝色
         0xFFFFFF00,  // 黄色
         0xFF000000,  // 黑色
         0xFF808080,  // 灰色
     };
     
     for (int i = 0; i < color_count; i++) {
         lv_obj_t *btn = lv_btn_create(toolbar);
         lv_obj_set_size(btn, btn_size, btn_size);
         lv_obj_set_style_bg_color(btn, lv_color_hex(0xFFFFFF), 0);
         lv_obj_set_style_border_width(btn, (i == 0) ? 4 : 2, 0);  // 默认选中红色
         lv_obj_set_style_border_color(btn, (i == 0) ? lv_color_hex(0x000000) : lv_color_hex(0xCCCCCC), 0);
         lv_obj_align(btn, LV_ALIGN_LEFT_MID, start_x + i * (btn_size + btn_spacing), 0);
         
         // 颜色预览（圆形）
         lv_obj_t *preview = lv_obj_create(btn);
         lv_obj_set_size(preview, 45, 45);
         // 使用RGB颜色值（lv_color_hex只需要RGB，去掉alpha通道）
         uint32_t rgb_color = colors_lvgl[i] & 0x00FFFFFF;  // 去掉alpha通道
         lv_obj_set_style_bg_color(preview, lv_color_hex(rgb_color), 0);
         lv_obj_set_style_radius(preview, LV_RADIUS_CIRCLE, 0);
         lv_obj_set_style_border_width(preview, 0, 0);
         lv_obj_clear_flag(preview, LV_OBJ_FLAG_CLICKABLE);  // 预览不拦截点击事件
         lv_obj_center(preview);
         
         color_btns[i] = btn;
         lv_obj_set_user_data(btn, (void*)(intptr_t)i);  // 存储索引
         lv_obj_add_event_cb(btn, color_select_cb, LV_EVENT_CLICKED, NULL);
     }
     
     // 创建右侧竖列工具栏（笔触大小）- 同一层级
     int right_btn_size = 60;
     int right_btn_spacing = 15;
     int right_toolbar_height = 280;  // 稍微拉长到280像素
     lv_obj_t *right_toolbar = lv_obj_create(touch_draw_window);
     lv_obj_set_size(right_toolbar, 80, right_toolbar_height);
     lv_obj_align(right_toolbar, LV_ALIGN_TOP_RIGHT, 0, 60);  // 从顶部工具栏下方开始，右侧对齐
     lv_obj_set_style_bg_color(right_toolbar, lv_color_hex(0xF5F5F5), 0);
     lv_obj_set_style_border_width(right_toolbar, 2, 0);
     lv_obj_set_style_border_color(right_toolbar, lv_color_hex(0xCCCCCC), 0);
     lv_obj_set_style_pad_all(right_toolbar, 8, 0);
     
     // 右侧工具栏按钮参数
     int right_start_y = 8;  // 从工具栏顶部padding开始
     
     // 创建3个笔触大小按钮（细、中、粗）- 竖列
     int pen_sizes[] = {8, 15, 22};  // 预览圆点大小
     for (int i = 0; i < 3; i++) {
         lv_obj_t *btn = lv_btn_create(right_toolbar);
         lv_obj_set_size(btn, right_btn_size, right_btn_size);
         lv_obj_set_style_bg_color(btn, lv_color_hex(0xFFFFFF), 0);
         lv_obj_set_style_border_width(btn, (i == 1) ? 3 : 2, 0);  // 默认选中"中"
         lv_obj_set_style_border_color(btn, (i == 1) ? lv_color_hex(0x0000FF) : lv_color_hex(0xCCCCCC), 0);
         lv_obj_align(btn, LV_ALIGN_TOP_MID, 0, right_start_y + i * (right_btn_size + right_btn_spacing));
         
         // 笔触大小预览（圆形点）
         lv_obj_t *preview = lv_obj_create(btn);
         lv_obj_set_size(preview, pen_sizes[i], pen_sizes[i]);
         lv_obj_set_style_bg_color(preview, lv_color_hex(0x000000), 0);
         lv_obj_set_style_radius(preview, LV_RADIUS_CIRCLE, 0);
         lv_obj_set_style_border_width(preview, 0, 0);
         lv_obj_clear_flag(preview, LV_OBJ_FLAG_CLICKABLE);  // 预览不拦截点击事件
         lv_obj_center(preview);
         
         pen_size_btns[i] = btn;
         lv_obj_set_user_data(btn, (void*)(intptr_t)i);  // 存储索引
         lv_obj_add_event_cb(btn, pen_size_select_cb, LV_EVENT_CLICKED, NULL);
     }
     
     // 橡皮擦按钮（底部工具栏右侧）
     int right_start_x = 800 - 20 - 2 * (btn_size + btn_spacing);  // 从右侧开始，留2个按钮的空间
     eraser_btn = lv_btn_create(toolbar);
     lv_obj_set_size(eraser_btn, btn_size, btn_size);
     lv_obj_set_style_bg_color(eraser_btn, lv_color_hex(0xFFFFFF), 0);
     lv_obj_set_style_border_width(eraser_btn, 2, 0);
     lv_obj_set_style_border_color(eraser_btn, lv_color_hex(0xCCCCCC), 0);
     lv_obj_align(eraser_btn, LV_ALIGN_LEFT_MID, right_start_x, 0);
     
     // 橡皮擦图标（使用FontAwesome橡皮擦图标 0xF12D）
     lv_obj_t *eraser_icon = lv_label_create(eraser_btn);
     extern const lv_font_t fa_solid_24;
     lv_label_set_text(eraser_icon, "\xEF\x84\xAD");  // FontAwesome eraser icon (U+F12D, UTF-8: \xEF\x84\xAD)
     lv_obj_set_style_text_font(eraser_icon, &fa_solid_24, 0);
     lv_obj_set_style_text_color(eraser_icon, lv_color_hex(0x666666), 0);
     lv_obj_set_style_text_align(eraser_icon, LV_TEXT_ALIGN_CENTER, 0);
     lv_obj_set_width(eraser_icon, LV_PCT(100));
     lv_obj_center(eraser_icon);
     lv_obj_clear_flag(eraser_icon, LV_OBJ_FLAG_CLICKABLE);  // 图标不拦截点击事件
     lv_obj_add_event_cb(eraser_btn, eraser_toggle_cb, LV_EVENT_CLICKED, NULL);
     
     // 清屏按钮（底部工具栏右侧，橡皮擦旁边）
     lv_obj_t *clear_btn = lv_btn_create(toolbar);
     lv_obj_set_size(clear_btn, btn_size, btn_size);
     lv_obj_set_style_bg_color(clear_btn, lv_color_hex(0xFFFFFF), 0);
     lv_obj_set_style_border_width(clear_btn, 2, 0);
     lv_obj_set_style_border_color(clear_btn, lv_color_hex(0xCCCCCC), 0);
     lv_obj_align(clear_btn, LV_ALIGN_LEFT_MID, right_start_x + btn_size + btn_spacing, 0);
     
     // 清屏图标（使用LVGL符号）
     lv_obj_t *clear_icon = lv_label_create(clear_btn);
     lv_label_set_text(clear_icon, LV_SYMBOL_TRASH);  // 使用LVGL内置垃圾桶图标
     lv_obj_set_style_text_font(clear_icon, &lv_font_montserrat_14, 0);
     lv_obj_set_style_text_color(clear_icon, lv_color_hex(0x666666), 0);
     lv_obj_set_style_text_align(clear_icon, LV_TEXT_ALIGN_CENTER, 0);
     lv_obj_set_width(clear_icon, LV_PCT(100));
     lv_obj_center(clear_icon);
     lv_obj_clear_flag(clear_icon, LV_OBJ_FLAG_CLICKABLE);  // 图标不拦截点击事件
     lv_obj_add_event_cb(clear_btn, clear_screen_cb, LV_EVENT_CLICKED, NULL);
     
     // 保存当前页面索引
     extern int get_current_page_index(void);
     saved_page_index = get_current_page_index();
     printf("[触摸绘图] 保存当前页面索引: %d\n", saved_page_index);
     
     // 创建协作绘图按钮（在标题栏左侧，返回按钮旁边）
     // 按钮布局：返回按钮(10,10,80x40) | 连接协作按钮(100,10,100x40) | 加入协作按钮(210,10,100x40) | 结束协作按钮(320,10,100x40)
     
     // 1. 连接协作按钮（作为主机开启协作）- 放在返回按钮右侧
     collab_connect_btn = lv_btn_create(touch_draw_window);
     lv_obj_set_size(collab_connect_btn, 100, 40);
     lv_obj_set_style_bg_color(collab_connect_btn, lv_color_hex(0x4CAF50), 0);  // 绿色
     lv_obj_align(collab_connect_btn, LV_ALIGN_TOP_LEFT, 100, 10);  // 返回按钮右侧
     lv_obj_t *collab_connect_label = lv_label_create(collab_connect_btn);
     lv_label_set_text(collab_connect_label, "连接协作");
     lv_obj_set_style_text_font(collab_connect_label, &SourceHanSansSC_VF, 0);
     lv_obj_center(collab_connect_label);
     lv_obj_add_event_cb(collab_connect_btn, collaborative_connect_cb, LV_EVENT_CLICKED, NULL);
     
     // 2. 加入协作按钮（作为客机加入他人的协作）
     collab_join_btn = lv_btn_create(touch_draw_window);
     lv_obj_set_size(collab_join_btn, 100, 40);
     lv_obj_set_style_bg_color(collab_join_btn, lv_color_hex(0x2196F3), 0);  // 蓝色
     lv_obj_align(collab_join_btn, LV_ALIGN_TOP_LEFT, 210, 10);  // 连接协作按钮右侧
     lv_obj_t *collab_join_label = lv_label_create(collab_join_btn);
     lv_label_set_text(collab_join_label, "加入协作");
     lv_obj_set_style_text_font(collab_join_label, &SourceHanSansSC_VF, 0);
     lv_obj_center(collab_join_label);
     lv_obj_add_event_cb(collab_join_btn, collaborative_join_cb, LV_EVENT_CLICKED, NULL);
     
     // 3. 结束协作按钮（结束主机或客机的协作）- 默认隐藏
     collab_end_btn = lv_btn_create(touch_draw_window);
     lv_obj_set_size(collab_end_btn, 100, 40);
     lv_obj_set_style_bg_color(collab_end_btn, lv_color_hex(0xF44336), 0);  // 红色
     lv_obj_align(collab_end_btn, LV_ALIGN_TOP_LEFT, 320, 10);  // 加入协作按钮右侧
     lv_obj_add_flag(collab_end_btn, LV_OBJ_FLAG_HIDDEN);  // 默认隐藏，连接成功后才显示
     lv_obj_t *collab_end_label = lv_label_create(collab_end_btn);
     lv_label_set_text(collab_end_label, "结束协作");
     lv_obj_set_style_text_font(collab_end_label, &SourceHanSansSC_VF, 0);
     lv_obj_center(collab_end_label);
     lv_obj_add_event_cb(collab_end_btn, collaborative_end_cb, LV_EVENT_CLICKED, NULL);
     
     // 初始化协作绘图模块（但不连接）
     // 注意：连接将通过按钮触发
     // 使用巴法云TCP协议进行设备间通信
     // 如果之前已经清理过（collaborative_mode为false），需要重新初始化
     if (!collaborative_mode) {
         collaborative_draw_config_t collab_config = {0};
         collab_config.enabled = true;
         strncpy(collab_config.server_host, "bemfa.com",  // 巴法云TCP服务器
                 sizeof(collab_config.server_host) - 1);
         collab_config.server_port = 8344;  // 巴法云TCP端口（8344为TCP协议端口）
         collab_config.user_id = (uint32_t)time(NULL) % 1000000;
         strncpy(collab_config.room_id, "default_room", sizeof(collab_config.room_id) - 1);
         strncpy(collab_config.device_name, COLLAB_DEVICE_NAME,  // 设备名称（TCP协议的主题）
                 sizeof(collab_config.device_name) - 1);
         strncpy(collab_config.private_key, COLLAB_PRIVATE_KEY,  // 个人私钥（TCP协议的UID）
                 sizeof(collab_config.private_key) - 1);
             
         if (collaborative_draw_init(&collab_config) == 0) {
             // 设置远程绘图回调
             collaborative_draw_set_remote_draw_callback(remote_draw_callback, NULL);
             collaborative_mode = true;
             printf("[触摸绘图] 协作绘图模块已重新初始化（等待连接）\n");
             // 注意：不在这里启动连接，等待用户点击按钮
         } else {
             printf("[触摸绘图] 协作绘图模块初始化失败\n");
             collaborative_mode = false;
         }
     } else {
         // 如果collaborative_mode已经是true，检查是否需要重新初始化
         // 检查模块状态，如果已断开连接但未初始化，重新初始化
         collaborative_draw_state_t state = collaborative_draw_get_state();
         if (state == COLLAB_DRAW_STATE_DISCONNECTED) {
             // 检查是否需要重新初始化（模块可能已经被清理）
             // 尝试初始化以确保模块就绪
             collaborative_draw_config_t collab_config = {0};
             collab_config.enabled = true;
             strncpy(collab_config.server_host, "bemfa.com",
                     sizeof(collab_config.server_host) - 1);
             collab_config.server_port = 8344;
             collab_config.user_id = (uint32_t)time(NULL) % 1000000;
             strncpy(collab_config.room_id, "default_room", sizeof(collab_config.room_id) - 1);
             strncpy(collab_config.device_name, COLLAB_DEVICE_NAME,
                     sizeof(collab_config.device_name) - 1);
             strncpy(collab_config.private_key, COLLAB_PRIVATE_KEY,
                     sizeof(collab_config.private_key) - 1);
             
             if (collaborative_draw_init(&collab_config) == 0) {
                 collaborative_draw_set_remote_draw_callback(remote_draw_callback, NULL);
                 printf("[触摸绘图] 协作绘图模块已初始化（等待连接）\n");
             }
         }
     }
     
     // 先确保触摸绘图模式未激活，允许LVGL正常刷新整个窗口
     touch_draw_running = false;
     
     // 切换到窗口
     lv_scr_load(touch_draw_window);
     
     // 等待LVGL完成初始渲染整个窗口（包括按钮和标题）
     for (int i = 0; i < 20; i++) {
         lv_timer_handler();
         usleep(10000);  // 10ms
     }
     lv_refr_now(NULL);
     
    // 额外等待，确保LVGL刷新完成
    usleep(50000);  // 50ms
    
#if USE_SDL
    // SDL虚拟机模式：使用framebuffer方式绘制（与开发板相同）
    // 初始化虚拟framebuffer和SDL窗口（必须在主线程中进行，SDL不是线程安全的）
    if (!sdl_framebuffer) {
        printf("[触摸绘图] 初始化SDL framebuffer和窗口（主线程，首次创建窗口）...\n");
        sdl_fb_init();
        
        if (!sdl_framebuffer) {
            printf("[触摸绘图] 错误：SDL framebuffer初始化失败\n");
        } else {
            printf("[触摸绘图] SDL framebuffer初始化成功\n");
        }
    }
    
    // 创建SDL刷新定时器（如果不存在）
    if (!sdl_refresh_timer) {
        sdl_refresh_timer = lv_timer_create(sdl_refresh_timer_cb, 16, NULL);  // 60fps
        printf("[触摸绘图] SDL刷新定时器已创建，周期16ms（framebuffer -> SDL窗口）\n");
    } else {
        printf("[触摸绘图] SDL刷新定时器已存在\n");
    }
    
    // 显示SDL覆盖窗口（必须在主线程中进行）
    if (sdl_overlay_window) {
        SDL_ShowWindow(sdl_overlay_window);
        // 设置窗口位置（在主窗口的(0, 60)位置）
        SDL_SetWindowPosition(sdl_overlay_window, 0, 60);
        printf("[触摸绘图] SDL覆盖窗口已显示: 720x340, 位置(0, 60)\n");
    } else {
        printf("[触摸绘图] 警告：SDL覆盖窗口未创建，轨迹将无法显示\n");
    }
    
    // 启动SDL鼠标输入处理线程（实现双向绘制）
    if (!sdl_mouse_thread_running && sdl_framebuffer) {
        sdl_mouse_thread_running = true;
        if (pthread_create(&sdl_mouse_thread, NULL, sdl_mouse_thread_func, NULL) == 0) {
            printf("[触摸绘图] SDL鼠标输入线程已启动（支持双向绘制）\n");
        } else {
            printf("[触摸绘图] 警告：SDL鼠标输入线程启动失败\n");
            sdl_mouse_thread_running = false;
        }
    }
    
    touch_draw_running = false;
    printf("[触摸绘图] SDL模式：使用SDL framebuffer显示，支持本地绘制和远程绘制\n");
#else
    // 在LVGL刷新完成后，再设置触摸绘图模式为激活（禁用LVGL刷新）
    touch_draw_running = true;
    printf("[触摸绘图] 触摸绘图模式已激活，LVGL刷新已禁用\n");
    
    // 然后清屏framebuffer为白色（只清屏60像素以下的区域，保留按钮和标题）
    int fb_fd = open(FRAMEBUFFER_DEV, O_RDWR);
    if (fb_fd >= 0) {
        struct fb_var_screeninfo vinfo;
        struct fb_fix_screeninfo finfo;
        
        if (ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo) == 0 &&
            ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo) == 0) {
            long int screensize = vinfo.yres * finfo.line_length;
            char *fbp = (char *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0);
            
            if ((intptr_t)fbp != -1) {
                // 清屏为白色（只清屏顶部、底部和右侧工具栏以外的区域）
                uint32_t* fb_ptr = (uint32_t*)fbp;
                int top_bar = 60;      // 顶部区域
                int bottom_bar = 80;   // 底部工具栏
                int right_bar = 80;    // 右侧工具栏
                int clear_right_start_x = vinfo.xres - right_bar;
                // 只清空中间绘图区域（排除右侧工具栏）
                for (int y = top_bar; y < vinfo.yres - bottom_bar; y++) {
                    for (int x = 0; x < clear_right_start_x; x++) {
                        int pixel_idx = y * vinfo.xres + x;
                        fb_ptr[pixel_idx] = COLOR_WHITE;
                    }
                }
                msync(fbp, screensize, MS_SYNC);
                munmap(fbp, screensize);
                printf("[触摸绘图] Framebuffer已清屏为白色（保留顶部区域）\n");
            }
        }
        close(fb_fd);
    }
    
    // 启动触摸绘图线程（线程会接管framebuffer管理）
    // 注意：touch_draw_running已经设置为true，所以直接创建线程
    // 确保之前的线程已完全退出
    if (touch_draw_thread != 0) {
        int thread_alive = pthread_kill(touch_draw_thread, 0);
        if (thread_alive == 0) {
            // 线程还在运行，先停止它
            printf("[触摸绘图] 检测到旧线程仍在运行，先停止\n");
            touch_draw_running = false;
            // 先关闭文件描述符以中断阻塞的read()
            if (touch_fd >= 0) {
                close(touch_fd);
                touch_fd = -1;
            }
            // 等待线程退出（带超时）
            for (int i = 0; i < 20; i++) {
                usleep(100000);  // 100ms
                thread_alive = pthread_kill(touch_draw_thread, 0);
                if (thread_alive != 0) {
                    break;
                }
            }
            if (thread_alive == 0) {
                printf("[触摸绘图] 警告：线程仍未退出，强制join\n");
            }
            pthread_join(touch_draw_thread, NULL);
            touch_draw_thread = 0;
            // 清理资源
            if (touch_fd >= 0) {
                close(touch_fd);
                touch_fd = -1;
            }
            if (fb_info.fbp != MAP_FAILED && fb_info.fbp != NULL) {
                munmap(fb_info.fbp, fb_info.screensize);
                fb_info.fbp = NULL;
            }
            if (fb_info.fd >= 0) {
                close(fb_info.fd);
                fb_info.fd = -1;
            }
            touch_draw_running = true;  // 重新设置
        } else {
            // 线程已退出，重置ID
            touch_draw_thread = 0;
        }
    }
    
    if (pthread_create(&touch_draw_thread, NULL, touch_draw_thread_func, NULL) != 0) {
        perror("[触摸绘图] Failed to create thread");
        touch_draw_running = false;
    } else {
        printf("[触摸绘图] 线程已启动\n");
    }
    
    // 等待线程初始化完成
    usleep(100000);  // 100ms，等待线程完成初始化
#endif
 }
 
 /**
  * @brief 隐藏触摸绘图窗口
  */
 void touch_draw_win_hide(void) {
     if (touch_draw_window != NULL) {
         lv_obj_add_flag(touch_draw_window, LV_OBJ_FLAG_HIDDEN);
     }
     touch_draw_cleanup();
 }
 
 /**
  * @brief 初始化触摸绘图模块
  */
 void touch_draw_init(void) {
     if (touch_draw_running) {
         return;
     }
     
     touch_draw_running = true;
     
     // 创建线程
     if (pthread_create(&touch_draw_thread, NULL, touch_draw_thread_func, NULL) != 0) {
         perror("[触摸绘图] Failed to create thread");
         touch_draw_running = false;
         return;
     }
     
     printf("[触摸绘图] 模块初始化完成\n");
 }
 
 /**
  * @brief 清理触摸绘图模块
  */
 void touch_draw_cleanup(void) {
#if USE_SDL
    // 删除SDL刷新定时器
    if (sdl_refresh_timer) {
        lv_timer_del(sdl_refresh_timer);
        sdl_refresh_timer = NULL;
    }
    
    // 隐藏SDL覆盖窗口
    if (sdl_overlay_window) {
        SDL_HideWindow(sdl_overlay_window);
    }
    
    // 清理SDL framebuffer
    sdl_fb_cleanup();
#endif
     // 防止重复清理
     static bool cleanup_in_progress = false;
     if (cleanup_in_progress) {
         printf("[触摸绘图] 清理已在进行中，跳过\n");
         return;
     }
     
     if (!touch_draw_running && touch_draw_thread == 0) {
         // 已经清理过了，直接返回
         return;
     }
     
     cleanup_in_progress = true;
     printf("[触摸绘图] 正在停止...\n");
     
     // 先设置标志，让线程知道要退出
     touch_draw_running = false;
     
    // 停止协作绘图
    if (collaborative_mode) {
        collaborative_draw_stop();
        collaborative_draw_cleanup();
        collaborative_mode = false;
    }
    
    // 清理远程绘图对象和framebuffer（虚拟机环境）
#if USE_SDL
    // 停止SDL鼠标输入线程
    if (sdl_mouse_thread_running) {
        printf("[触摸绘图] 停止SDL鼠标输入线程...\n");
        sdl_mouse_thread_running = false;
        
        // 等待线程退出
        if (sdl_mouse_thread != 0) {
            pthread_join(sdl_mouse_thread, NULL);
            sdl_mouse_thread = 0;
        }
        printf("[触摸绘图] SDL鼠标输入线程已停止\n");
    }
    
    // 删除SDL刷新定时器
    if (sdl_refresh_timer) {
        lv_timer_del(sdl_refresh_timer);
        sdl_refresh_timer = NULL;
    }
    
    // 隐藏SDL覆盖窗口
    if (sdl_overlay_window) {
        SDL_HideWindow(sdl_overlay_window);
    }
    
    // 清理SDL framebuffer
    sdl_fb_cleanup();
#endif
     
     // 关闭文件描述符以中断阻塞的read()调用
     // 这会让线程中的read()立即返回（EBADF），从而退出循环
     if (touch_fd >= 0) {
         printf("[触摸绘图] 关闭触摸设备文件描述符以中断线程\n");
         close(touch_fd);
         touch_fd = -1;
     }
     
     // 等待线程退出（带超时）
     if (touch_draw_thread != 0) {
         // 先检查线程是否还在运行
         int thread_alive = pthread_kill(touch_draw_thread, 0);
         if (thread_alive == 0) {
             // 线程还在运行，等待其退出（最多等待2秒）
             printf("[触摸绘图] 等待线程退出...\n");
             for (int i = 0; i < 20; i++) {
                 usleep(100000);  // 100ms
                 thread_alive = pthread_kill(touch_draw_thread, 0);
                 if (thread_alive != 0) {
                     // 线程已退出
                     break;
                 }
             }
             
             if (thread_alive == 0) {
                 printf("[触摸绘图] 警告：线程仍在运行，强制join\n");
             }
             
             // 尝试join线程（即使可能失败）
             if (pthread_join(touch_draw_thread, NULL) != 0) {
                 perror("[触摸绘图] Failed to join thread");
                 // 如果join失败，尝试detach线程（避免成为僵尸线程）
                 printf("[触摸绘图] 尝试detach线程...\n");
                 pthread_detach(touch_draw_thread);
             }
         } else {
             printf("[触摸绘图] 线程已退出，清理线程ID\n");
         }
         touch_draw_thread = 0;
     }
     
     // 确保资源已清理（线程退出时会清理，但这里再次确认）
     if (touch_fd >= 0) {
         close(touch_fd);
         touch_fd = -1;
     }
     if (fb_info.fbp != MAP_FAILED && fb_info.fbp != NULL) {
         munmap(fb_info.fbp, fb_info.screensize);
         fb_info.fbp = NULL;
     }
     if (fb_info.fd >= 0) {
         close(fb_info.fd);
         fb_info.fd = -1;
     }
     
     cleanup_in_progress = false;
     printf("[触摸绘图] 模块清理完成\n");
 }
 
 /**
  * @brief 检查触摸绘图模式是否激活
  */
 bool touch_draw_is_active(void) {
     return touch_draw_running;
 }
 
 /**
  * @brief 启用/禁用协作绘图模式
  */
 void touch_draw_set_collaborative_mode(bool enabled) {
     collaborative_mode = enabled;
     printf("[触摸绘图] 协作模式: %s\n", enabled ? "启用" : "禁用");
 }
 
 /**
  * @brief 获取协作绘图模式状态
  */
 bool touch_draw_get_collaborative_mode(void) {
     return collaborative_mode;
 }
 