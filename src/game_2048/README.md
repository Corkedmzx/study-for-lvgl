# Game 2048 模块文档

## 模块概述

`game_2048` 模块实现了经典的2048数字游戏逻辑。该模块提供游戏状态管理、移动操作、合并逻辑、游戏结束检测等功能。

## 文件结构

- `game_2048.h` - 游戏逻辑接口定义
- `game_2048.c` - 游戏逻辑实现

## 主要功能

### 1. 游戏状态结构

```c
typedef struct {
    int grid[GRID_SIZE][GRID_SIZE];  // 游戏网格（4x4）
    int score;                        // 当前分数
    bool game_over;                   // 游戏是否结束
    bool moved;                       // 本次操作是否移动了方块
} game_2048_t;
```

- `GRID_SIZE` - 网格大小，定义为4（4x4网格）
- `grid` - 4x4的整数数组，存储每个格子的数字（0表示空格）
- `score` - 当前分数，合并方块时累加
- `game_over` - 游戏结束标志
- `moved` - 本次移动是否有效（用于判断是否需要添加新方块）

### 2. 游戏初始化

#### `game_2048_init()`

初始化游戏。

**函数签名：**
```c
void game_2048_init(game_2048_t *game);
```

**功能：**
- 清空游戏网格（所有格子设为0）
- 重置分数为0
- 重置游戏结束标志
- 添加两个初始方块（随机位置，值为2）

**调用位置：**
- `src/ui/game_2048_win.c:918` - 游戏窗口初始化时

**实现细节：**
1. 检查game指针有效性
2. 使用 `memset()` 清空网格
3. 重置所有状态变量
4. 调用 `game_2048_add_random_tile()` 添加两个初始方块

### 3. 添加随机方块

#### `game_2048_add_random_tile()`

在随机空位置添加数字2（90%概率）或4（10%概率）。

**函数签名：**
```c
bool game_2048_add_random_tile(game_2048_t *game);
```

**功能：**
- 查找所有空位置（值为0的格子）
- 随机选择一个空位置
- 添加数字2（90%概率）或4（10%概率）

**返回值：**
- 成功返回true
- 网格已满返回false

**调用位置：**
- `game_2048_init()` - 初始化时添加两个方块
- 每次有效移动后添加一个新方块

**实现细节：**
1. 遍历网格，收集所有空位置
2. 如果无空位置，返回false
3. 使用随机数选择一个空位置
4. 90%概率添加2，10%概率添加4

### 4. 移动操作

#### `game_2048_move_left()`

向左滑动。

**函数签名：**
```c
bool game_2048_move_left(game_2048_t *game);
```

**功能：**
- 对每一行进行左移操作
- 移除零，向左压缩
- 合并相同的数字
- 再次压缩
- 如果移动了，添加新方块并更新分数

**返回值：**
- 发生了移动返回true，否则返回false

**调用位置：**
- `src/ui/game_2048_win.c:364` - 触屏左划时

#### `game_2048_move_right()`

向右滑动。

**函数签名：**
```c
bool game_2048_move_right(game_2048_t *game);
```

**功能：**
- 对每一行进行右移操作
- 实现方式：反转行，左移，再反转

**调用位置：**
- `src/ui/game_2048_win.c:361` - 触屏右划时

#### `game_2048_move_up()`

向上滑动。

**函数签名：**
```c
bool game_2048_move_up(game_2048_t *game);
```

**功能：**
- 对每一列进行上移操作
- 实现方式：转置，左移，再转置

**调用位置：**
- `src/ui/game_2048_win.c:377` - 触屏上划时

#### `game_2048_move_down()`

向下滑动。

**函数签名：**
```c
bool game_2048_move_down(game_2048_t *game);
```

**功能：**
- 对每一列进行下移操作
- 实现方式：转置，反转，左移，反转，再转置

**调用位置：**
- `src/ui/game_2048_win.c:374` - 触屏下划时

### 5. 移动算法

所有移动操作都基于 `move_row_left()` 函数：

1. **压缩阶段**：
   - 移除零，向左压缩
   - 记录是否发生了移动

2. **合并阶段**：
   - 从左到右遍历，合并相邻的相同数字
   - 合并后的数字翻倍
   - 记录是否发生了移动

3. **再次压缩**：
   - 移除合并后产生的零
   - 再次压缩

4. **其他方向**：
   - 右移：反转行，左移，再反转
   - 上移：转置列，左移，再转置
   - 下移：转置列，反转，左移，反转，再转置

### 6. 游戏结束检测

#### `game_2048_check_game_over()`

检查游戏是否结束（无法移动）。

**函数签名：**
```c
bool game_2048_check_game_over(game_2048_t *game);
```

**功能：**
- 检查是否有空位置
- 如果有空位置，游戏继续
- 如果无空位置，检查是否可以合并
- 如果无法合并，游戏结束

**返回值：**
- 游戏结束返回true，否则返回false

**调用位置：**
- 每次移动后自动调用
- 如果游戏结束，设置 `game->game_over = true`

**实现细节：**
1. 遍历网格，查找空位置
2. 如果有空位置，返回false（游戏继续）
3. 如果无空位置，检查每个格子是否可以与相邻格子合并
4. 检查右边和下边（避免重复检查）
5. 如果无法合并，返回true（游戏结束）

### 7. 重置游戏

#### `game_2048_reset()`

重置游戏。

**函数签名：**
```c
void game_2048_reset(game_2048_t *game);
```

**功能：**
- 调用 `game_2048_init()` 重新初始化游戏

**调用位置：**
- `src/ui/game_2048_win.c` - 游戏窗口重置按钮

## 模块调用关系

### 被调用情况

1. **src/ui/game_2048_win.c**
   ```c
   // 初始化游戏
   game_2048_init(&game_state);
   
   // 移动操作
   game_2048_move_left(&game_state);
   game_2048_move_right(&game_state);
   game_2048_move_up(&game_state);
   game_2048_move_down(&game_state);
   
   // 重置游戏
   game_2048_reset(&game_state);
   ```

### 依赖关系

- **标准C库**：`stdlib.h`, `string.h`, `time.h`
- **不依赖其他项目模块**

## 使用示例

### 示例1：初始化游戏

```c
#include "src/game_2048/game_2048.h"

game_2048_t game;
game_2048_init(&game);

printf("游戏初始化完成，分数: %d\n", game.score);
```

### 示例2：执行移动

```c
game_2048_t game;
game_2048_init(&game);

// 向左移动
if (game_2048_move_left(&game)) {
    printf("移动成功，分数: %d\n", game.score);
    
    // 检查游戏是否结束
    if (game.game_over) {
        printf("游戏结束！\n");
    }
}
```

### 示例3：完整游戏循环

```c
game_2048_t game;
game_2048_init(&game);

while (!game.game_over) {
    // 获取用户输入（左/右/上/下）
    char direction = get_user_input();
    
    bool moved = false;
    switch (direction) {
        case 'L': moved = game_2048_move_left(&game); break;
        case 'R': moved = game_2048_move_right(&game); break;
        case 'U': moved = game_2048_move_up(&game); break;
        case 'D': moved = game_2048_move_down(&game); break;
    }
    
    if (moved) {
        printf("分数: %d\n", game.score);
        // 更新UI显示
    }
}

printf("游戏结束！最终分数: %d\n", game.score);
```

## 实现细节

### 分数计算

分数在移动操作中计算：
- 比较移动前后的网格
- 如果某个位置的值是旧值的2倍，说明发生了合并
- 将合并后的数字累加到分数中

### 随机数生成

使用 `rand()` 生成随机数：
- 在 `game_2048_add_random_tile()` 中选择随机位置
- 90%概率添加2，10%概率添加4

**注意**：需要在程序开始时调用 `srand()` 初始化随机数种子。

### 移动有效性

每次移动操作都会设置 `game->moved` 标志：
- 如果发生了移动，标志为true
- 如果未发生移动，标志为false
- 只有移动有效时才添加新方块

## 注意事项

1. **随机数种子**：需要在程序开始时调用 `srand(time(NULL))` 初始化随机数
2. **内存管理**：游戏状态结构由调用者管理，不需要动态分配
3. **线程安全**：模块不是线程安全的，应在单线程中使用
4. **网格大小**：当前固定为4x4，如需修改需要修改 `GRID_SIZE` 定义
5. **分数计算**：分数在合并时累加，合并后的数字就是增加的分数

## 相关文件

- `src/ui/game_2048_win.c` - 2048游戏窗口，使用游戏逻辑模块

## 游戏规则

1. **初始状态**：4x4网格，随机两个位置有数字2
2. **移动规则**：
   - 所有方块向指定方向移动
   - 相同数字的方块合并，数字翻倍
   - 每次移动后，随机空位置出现新方块（2或4）
3. **得分规则**：合并时，合并后的数字累加到分数
4. **游戏结束**：网格填满且无法合并时游戏结束
5. **胜利条件**：达到2048（或其他目标数字，由UI决定）

